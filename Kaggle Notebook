{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "be348b5e",
   "metadata": {
    "papermill": {
     "duration": 0.004917,
     "end_time": "2025-04-28T00:51:03.083641",
     "exception": false,
     "start_time": "2025-04-28T00:51:03.078724",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# 1. Imports and setup"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "56f73a88",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:03.092584Z",
     "iopub.status.busy": "2025-04-28T00:51:03.092331Z",
     "iopub.status.idle": "2025-04-28T00:51:17.978829Z",
     "shell.execute_reply": "2025-04-28T00:51:17.978040Z"
    },
    "papermill": {
     "duration": 14.89257,
     "end_time": "2025-04-28T00:51:17.980309",
     "exception": false,
     "start_time": "2025-04-28T00:51:03.087739",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2025-04-28 00:51:06.710996: E external/local_xla/xla/stream_executor/cuda/cuda_fft.cc:477] Unable to register cuFFT factory: Attempting to register factory for plugin cuFFT when one has already been registered\n",
      "WARNING: All log messages before absl::InitializeLog() is called are written to STDERR\n",
      "E0000 00:00:1745801466.920293      20 cuda_dnn.cc:8310] Unable to register cuDNN factory: Attempting to register factory for plugin cuDNN when one has already been registered\n",
      "E0000 00:00:1745801466.977900      20 cuda_blas.cc:1418] Unable to register cuBLAS factory: Attempting to register factory for plugin cuBLAS when one has already been registered\n"
     ]
    }
   ],
   "source": [
    "# Imports and setup\n",
    "import os\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from PIL import Image\n",
    "import cv2\n",
    "import tensorflow as tf\n",
    "from tensorflow.keras import layers, models\n",
    "from tensorflow.keras.optimizers import Adam\n",
    "import gc\n",
    "from tqdm.notebook import tqdm\n",
    "import time\n",
    "import threading\n",
    "from concurrent.futures import ThreadPoolExecutor\n",
    "\n",
    "# Set random seeds for reproducibility\n",
    "np.random.seed(42)\n",
    "tf.random.set_seed(42)\n",
    "\n",
    "# Define paths\n",
    "DATA_PATH = \"/kaggle/input/byu-locating-bacterial-flagellar-motors-2025/\"\n",
    "TRAIN_PATH = os.path.join(DATA_PATH, \"train\")\n",
    "TRAIN_LABELS = os.path.join(DATA_PATH, \"train_labels.csv\")\n",
    "TEST_PATH = os.path.join(DATA_PATH, \"test\")\n",
    "SUBMISSION_PATH = \"/kaggle/working/submission.csv\"\n",
    "\n",
    "# Detection parameters \n",
    "CONFIDENCE_THRESHOLD = 0.35  # Threshold for considering a detection\n",
    "NMS_IOU_THRESHOLD = 0.2     # IoU threshold for 3D NMS clustering\n",
    "MAX_DETECTIONS_PER_TOMO = 1 # Maximum number of motors per tomogram (for test set)\n",
    "IMAGE_SIZE = (224, 224)     # Size to resize slices to\n",
    "BATCH_SIZE = 6              # Default batch size, will be adjusted dynamically"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7c330826",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:17.989890Z",
     "iopub.status.busy": "2025-04-28T00:51:17.989477Z",
     "iopub.status.idle": "2025-04-28T00:51:17.992905Z",
     "shell.execute_reply": "2025-04-28T00:51:17.992394Z"
    },
    "papermill": {
     "duration": 0.009152,
     "end_time": "2025-04-28T00:51:17.993862",
     "exception": false,
     "start_time": "2025-04-28T00:51:17.984710",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Disable mixed precision globally to avoid type mismatches\n",
    "tf.keras.mixed_precision.set_global_policy('float32')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "531bd50f",
   "metadata": {
    "papermill": {
     "duration": 0.003683,
     "end_time": "2025-04-28T00:51:18.001562",
     "exception": false,
     "start_time": "2025-04-28T00:51:17.997879",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# 2. Memory managment and utitlity functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "ad8f8c39",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.010014Z",
     "iopub.status.busy": "2025-04-28T00:51:18.009803Z",
     "iopub.status.idle": "2025-04-28T00:51:18.016096Z",
     "shell.execute_reply": "2025-04-28T00:51:18.015612Z"
    },
    "papermill": {
     "duration": 0.011685,
     "end_time": "2025-04-28T00:51:18.017113",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.005428",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Memory management and GPU optimization\n",
    "def clear_memory():\n",
    "    \"\"\"Clear memory to prevent OOM errors\"\"\"\n",
    "    gc.collect()\n",
    "    \n",
    "    # If GPU is available, also clear GPU memory\n",
    "    if tf.config.list_physical_devices('GPU'):\n",
    "        tf.keras.backend.clear_session()\n",
    "\n",
    "def optimize_gpu():\n",
    "    \"\"\"Configure GPU settings for optimal performance with safe mixed precision\"\"\"\n",
    "    # Check for GPU availability\n",
    "    gpus = tf.config.list_physical_devices('GPU')\n",
    "    \n",
    "    if len(gpus) > 0:\n",
    "        print(f\"Found {len(gpus)} GPU(s)\")\n",
    "        \n",
    "        # Enable memory growth to avoid OOM errors\n",
    "        for gpu in gpus:\n",
    "            try:\n",
    "                tf.config.experimental.set_memory_growth(gpu, True)\n",
    "                print(f\"Memory growth enabled for {gpu}\")\n",
    "            except RuntimeError as e:\n",
    "                print(f\"Error setting memory growth: {e}\")\n",
    "        \n",
    "        # For mixed precision, we'll disable policy and use explicit type casting instead\n",
    "        # This avoids incompatible type errors\n",
    "        print(\"Using explicit type casting for mixed precision operations\")\n",
    "        \n",
    "        # Set XLA optimization for faster execution\n",
    "        tf.config.optimizer.set_jit(True)\n",
    "        print(\"XLA JIT compilation enabled\")\n",
    "        \n",
    "        # Estimate reasonable batch size based on GPU memory\n",
    "        batch_size = 6  # Default batch size for GPU\n",
    "        return batch_size, True\n",
    "    else:\n",
    "        print(\"No GPU found\")\n",
    "        return 4, False  # Reduced batch size for CPU\n",
    "\n",
    "# Timer class for profiling\n",
    "class Timer:\n",
    "    def __init__(self, name):\n",
    "        self.name = name\n",
    "        self.start_time = None\n",
    "    \n",
    "    def __enter__(self):\n",
    "        self.start_time = time.time()\n",
    "        return self\n",
    "    \n",
    "    def __exit__(self, *args):\n",
    "        elapsed = time.time() - self.start_time\n",
    "        print(f\"[TIMER] {self.name}: {elapsed:.3f}s\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "03eca4fc",
   "metadata": {
    "papermill": {
     "duration": 0.003783,
     "end_time": "2025-04-28T00:51:18.024906",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.021123",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# 3. Image processing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "19c86b9f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.033438Z",
     "iopub.status.busy": "2025-04-28T00:51:18.033211Z",
     "iopub.status.idle": "2025-04-28T00:51:18.039376Z",
     "shell.execute_reply": "2025-04-28T00:51:18.038823Z"
    },
    "papermill": {
     "duration": 0.011652,
     "end_time": "2025-04-28T00:51:18.040421",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.028769",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Image processing functions\n",
    "def normalize_slice(slice_data):\n",
    "    \"\"\"Normalize slice data using 2nd and 98th percentiles for better contrast\"\"\"\n",
    "    p2 = np.percentile(slice_data, 2)\n",
    "    p98 = np.percentile(slice_data, 98)\n",
    "    clipped_data = np.clip(slice_data, p2, p98)\n",
    "    normalized = 255 * (clipped_data - p2) / (p98 - p2)\n",
    "    return np.uint8(normalized)\n",
    "\n",
    "def enhance_slice(slice_img):\n",
    "    \"\"\"Apply preprocessing to enhance motor features in a slice\"\"\"\n",
    "    # Convert to uint8 if needed\n",
    "    if slice_img.dtype != np.uint8:\n",
    "        slice_img = slice_img.astype(np.uint8)\n",
    "        \n",
    "    # Apply CLAHE for contrast enhancement\n",
    "    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n",
    "    enhanced = clahe.apply(slice_img)\n",
    "    \n",
    "    # Apply light Gaussian blur to reduce noise\n",
    "    enhanced = cv2.GaussianBlur(enhanced, (3, 3), 0)\n",
    "    \n",
    "    # Apply histogram equalization for better feature visibility\n",
    "    enhanced = cv2.equalizeHist(enhanced)\n",
    "    \n",
    "    return enhanced\n",
    "\n",
    "def preload_image_batch(file_paths):\n",
    "    \"\"\"Preload a batch of images to CPU memory\"\"\"\n",
    "    images = []\n",
    "    for path in file_paths:\n",
    "        try:\n",
    "            # First try OpenCV\n",
    "            img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)\n",
    "            if img is None:\n",
    "                # Fallback to PIL\n",
    "                img = np.array(Image.open(path).convert('L'))\n",
    "            \n",
    "            # Apply enhancement\n",
    "            img = enhance_slice(img)\n",
    "            images.append(img)\n",
    "        except Exception as e:\n",
    "            print(f\"Error loading image {path}: {e}\")\n",
    "            # Add empty image as fallback\n",
    "            images.append(np.zeros((IMAGE_SIZE[0], IMAGE_SIZE[1]), dtype=np.uint8))\n",
    "    return images"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "de836357",
   "metadata": {
    "papermill": {
     "duration": 0.00369,
     "end_time": "2025-04-28T00:51:18.048145",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.044455",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# 4. Data prep and loading"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "3bb58d17",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.057082Z",
     "iopub.status.busy": "2025-04-28T00:51:18.056896Z",
     "iopub.status.idle": "2025-04-28T00:51:18.078270Z",
     "shell.execute_reply": "2025-04-28T00:51:18.077746Z"
    },
    "papermill": {
     "duration": 0.027169,
     "end_time": "2025-04-28T00:51:18.079247",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.052078",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Dataset preparation and loading\n",
    "def create_train_val_split(labels_df, val_fraction=0.2, random_state=42):\n",
    "    \"\"\"Split the data into training and validation sets by tomogram ID\"\"\"\n",
    "    unique_ids = labels_df['tomo_id'].unique()\n",
    "    np.random.seed(random_state)\n",
    "    np.random.shuffle(unique_ids)\n",
    "    \n",
    "    split_idx = int(len(unique_ids) * (1 - val_fraction))\n",
    "    train_ids = unique_ids[:split_idx]\n",
    "    val_ids = unique_ids[split_idx:]\n",
    "    \n",
    "    return train_ids, val_ids\n",
    "\n",
    "# Data generator for efficient loading\n",
    "class TomogramDataGenerator(tf.keras.utils.Sequence):\n",
    "    def __init__(self, tomo_ids, labels_df=None, batch_size=1, shuffle=True,\n",
    "                 slice_sampling_factor=0.5, max_slices=64, resize=(320, 320),\n",
    "                 is_test=False, augment=False):\n",
    "        \n",
    "        self.tomo_ids = tomo_ids\n",
    "        self.labels_df = labels_df\n",
    "        self.batch_size = batch_size\n",
    "        self.shuffle = shuffle\n",
    "        self.slice_sampling_factor = slice_sampling_factor\n",
    "        self.max_slices = max_slices\n",
    "        self.resize = resize\n",
    "        self.is_test = is_test\n",
    "        self.augment = augment\n",
    "        self.data_path = TEST_PATH if is_test else TRAIN_PATH\n",
    "        \n",
    "        # Precompute tomogram metadata for more efficient loading\n",
    "        self.tomo_metadata = {}\n",
    "        \n",
    "        for tomo_id in self.tomo_ids:\n",
    "            # Get info about this tomogram\n",
    "            if not is_test and labels_df is not None:\n",
    "                tomo_info = labels_df[labels_df['tomo_id'] == tomo_id]\n",
    "                if len(tomo_info) > 0:\n",
    "                    tomo_info = tomo_info.iloc[0]\n",
    "                    self.tomo_metadata[tomo_id] = {\n",
    "                        'shape': (\n",
    "                            int(tomo_info['Array shape (axis 0)']),\n",
    "                            int(tomo_info['Array shape (axis 1)']),\n",
    "                            int(tomo_info['Array shape (axis 2)'])\n",
    "                        ),\n",
    "                        'spacing': float(tomo_info['Voxel spacing']),\n",
    "                        'motor_count': int(tomo_info['Number of motors'])\n",
    "                    }\n",
    "            else:\n",
    "                # For test data, determine the shape when loading\n",
    "                folder_path = os.path.join(self.data_path, tomo_id)\n",
    "                slice_files = sorted([f for f in os.listdir(folder_path) \n",
    "                                     if f.startswith('slice_') and f.endswith('.jpg')])\n",
    "                \n",
    "                # Sample first slice to get dimensions\n",
    "                sample_path = os.path.join(folder_path, slice_files[0])\n",
    "                with Image.open(sample_path) as img:\n",
    "                    width, height = img.size\n",
    "                \n",
    "                self.tomo_metadata[tomo_id] = {\n",
    "                    'shape': (len(slice_files), height, width),\n",
    "                    'slice_count': len(slice_files)\n",
    "                }\n",
    "        \n",
    "        self.on_epoch_end()\n",
    "    \n",
    "    def __len__(self):\n",
    "        \"\"\"Number of batches per epoch\"\"\"\n",
    "        return int(np.ceil(len(self.tomo_ids) / self.batch_size))\n",
    "    \n",
    "    def __getitem__(self, index):\n",
    "        \"\"\"Generate one batch of data\"\"\"\n",
    "        # Get tomogram IDs for this batch\n",
    "        batch_ids = self.tomo_ids[index * self.batch_size:\n",
    "                                  min((index + 1) * self.batch_size, len(self.tomo_ids))]\n",
    "        \n",
    "        # Initialize batch arrays\n",
    "        batch_x = []\n",
    "        batch_y = []\n",
    "        \n",
    "        # Generate data for each tomogram in the batch\n",
    "        for tomo_id in batch_ids:\n",
    "            # Load the 3D volume\n",
    "            volume = self._load_tomogram(tomo_id)\n",
    "            batch_x.append(volume)\n",
    "            \n",
    "            if not self.is_test and self.labels_df is not None:\n",
    "                # Get the labels for training data\n",
    "                motor_locations = self._get_motor_locations(tomo_id)\n",
    "                batch_y.append(motor_locations)\n",
    "        \n",
    "        # Convert to numpy arrays\n",
    "        batch_x = np.array(batch_x, dtype=np.float32)\n",
    "        \n",
    "        if not self.is_test and self.labels_df is not None:\n",
    "            batch_y = np.array(batch_y, dtype=np.float32)\n",
    "            return batch_x, batch_y\n",
    "        else:\n",
    "            return batch_x, batch_ids\n",
    "    \n",
    "    def _load_tomogram(self, tomo_id):\n",
    "        \"\"\"Load a tomogram with sampling to fit in memory\"\"\"\n",
    "        folder_path = os.path.join(self.data_path, tomo_id)\n",
    "        \n",
    "        # Get all slice files\n",
    "        slice_files = sorted([f for f in os.listdir(folder_path) \n",
    "                             if f.startswith('slice_') and f.endswith('.jpg')])\n",
    "        \n",
    "        # Use higher sampling for test data\n",
    "        actual_sampling_factor = 0.8 if self.is_test else self.slice_sampling_factor\n",
    "        \n",
    "        # Apply slice sampling to reduce memory usage\n",
    "        if actual_sampling_factor < 1.0:\n",
    "            num_slices = max(int(len(slice_files) * actual_sampling_factor), 1)\n",
    "            indices = np.linspace(0, len(slice_files) - 1, num_slices, dtype=int)\n",
    "            slice_files = [slice_files[i] for i in indices]\n",
    "        \n",
    "        # Ensure we have exactly max_slices\n",
    "        if self.max_slices:\n",
    "            if len(slice_files) > self.max_slices:\n",
    "                # If more slices than needed, sample evenly\n",
    "                indices = np.linspace(0, len(slice_files) - 1, self.max_slices, dtype=int)\n",
    "                slice_files = [slice_files[i] for i in indices]\n",
    "            elif len(slice_files) < self.max_slices:\n",
    "                # If fewer slices than needed, pad with repeats of nearby slices\n",
    "                needed = self.max_slices - len(slice_files)\n",
    "                padding = []\n",
    "                for i in range(needed):\n",
    "                    idx = min(i % len(slice_files), len(slice_files)-1)\n",
    "                    padding.append(slice_files[idx])\n",
    "                slice_files = slice_files + padding\n",
    "        \n",
    "        # Initialize volume with correct shape\n",
    "        height, width = self.resize\n",
    "        volume = np.zeros((len(slice_files), height, width, 1), dtype=np.float32)\n",
    "        \n",
    "        # Process each slice\n",
    "        for i, slice_file in enumerate(slice_files):\n",
    "            try:\n",
    "                # Load and process the slice efficiently\n",
    "                slice_path = os.path.join(folder_path, slice_file)\n",
    "                \n",
    "                # Using PIL for loading\n",
    "                with Image.open(slice_path) as img:\n",
    "                    if self.resize:\n",
    "                        img = img.resize(self.resize, Image.BICUBIC)\n",
    "                    \n",
    "                    # Convert to numpy array\n",
    "                    img_array = np.array(img.convert('L'), dtype=np.float32)\n",
    "                    \n",
    "                    # Apply enhancement for better feature visibility\n",
    "                    img_array = enhance_slice(img_array.astype(np.uint8)).astype(np.float32)\n",
    "                    \n",
    "                    # Normalize to [0,1] range\n",
    "                    img_array = img_array / 255.0\n",
    "                \n",
    "                # Add channel dimension\n",
    "                img_array = np.expand_dims(img_array, axis=-1)\n",
    "                \n",
    "                # Store in volume\n",
    "                volume[i, :, :, 0] = img_array[:, :, 0]\n",
    "                \n",
    "                # Force garbage collection periodically\n",
    "                if i % 20 == 0:\n",
    "                    gc.collect()\n",
    "            \n",
    "            except Exception as e:\n",
    "                print(f\"Error loading slice {slice_file} from {tomo_id}: {e}\")\n",
    "                # Fill with zeros on error\n",
    "                volume[i, :, :, 0] = 0\n",
    "        \n",
    "        # Apply data augmentation if needed\n",
    "        if self.augment and not self.is_test:\n",
    "            volume = self._augment_volume(volume)\n",
    "        \n",
    "        return volume\n",
    "    \n",
    "    def _augment_volume(self, volume):\n",
    "        \"\"\"Apply simple 3D data augmentation to the volume\"\"\"\n",
    "        # Only apply augmentation with 50% probability\n",
    "        if np.random.rand() < 0.5:\n",
    "            return volume\n",
    "        \n",
    "        # Apply a random transformation\n",
    "        aug_type = np.random.choice(['flip', 'rotate', 'noise'])\n",
    "        \n",
    "        if aug_type == 'flip':\n",
    "            # Flip in y or x direction\n",
    "            axis = np.random.choice([1, 2])\n",
    "            volume = np.flip(volume, axis=axis)\n",
    "        \n",
    "        elif aug_type == 'rotate':\n",
    "            # 90, 180, or 270 degree rotation in the y-x plane\n",
    "            k = np.random.choice([1, 2, 3])\n",
    "            volume = np.rot90(volume, k=k, axes=(1, 2))\n",
    "        \n",
    "        elif aug_type == 'noise':\n",
    "            # Add random noise\n",
    "            noise_level = np.random.uniform(0.01, 0.05)\n",
    "            noise = np.random.normal(0, noise_level, volume.shape)\n",
    "            volume = np.clip(volume + noise, 0, 1)\n",
    "        \n",
    "        return volume\n",
    "    \n",
    "    def _get_motor_locations(self, tomo_id):\n",
    "        \"\"\"Get motor locations with coordinates normalized to [0,1]\"\"\"\n",
    "        # Get all motor labels for this tomogram\n",
    "        tomo_labels = self.labels_df[self.labels_df['tomo_id'] == tomo_id]\n",
    "        \n",
    "        # Get tomogram shape from metadata\n",
    "        if tomo_id in self.tomo_metadata:\n",
    "            tomo_shape = self.tomo_metadata[tomo_id]['shape']\n",
    "        else:\n",
    "            # Fallback shape if metadata not available\n",
    "            tomo_shape = (100, 100, 100)  # Default values\n",
    "        \n",
    "        # For simplified detection, we'll use a single tensor\n",
    "        # [has_motor, z, y, x] where coordinates are normalized to [0,1]\n",
    "        # Return shape will be [1, 4]\n",
    "        motor_locations = np.zeros((1, 4), dtype=np.float32)\n",
    "        \n",
    "        # If no motors, return zero tensor\n",
    "        if len(tomo_labels) == 0:\n",
    "            return motor_locations\n",
    "        \n",
    "        # For simplicity, use only first motor if multiple exist\n",
    "        motor = tomo_labels.iloc[0]\n",
    "        \n",
    "        # Extract 3D coordinates\n",
    "        z = float(motor['Motor axis 0'])\n",
    "        y = float(motor['Motor axis 1'])\n",
    "        x = float(motor['Motor axis 2'])\n",
    "        \n",
    "        # Skip invalid coordinates\n",
    "        if z < 0 or y < 0 or x < 0:\n",
    "            return motor_locations\n",
    "        \n",
    "        # Normalize coordinates to [0,1] range\n",
    "        z_norm = z / tomo_shape[0]\n",
    "        y_norm = y / tomo_shape[1]\n",
    "        x_norm = x / tomo_shape[2]\n",
    "        \n",
    "        # Store [has_motor, z_norm, y_norm, x_norm]\n",
    "        motor_locations[0] = [1.0, z_norm, y_norm, x_norm]\n",
    "        \n",
    "        return motor_locations\n",
    "    \n",
    "    def on_epoch_end(self):\n",
    "        \"\"\"Updates indexes after each epoch\"\"\"\n",
    "        if self.shuffle:\n",
    "            np.random.shuffle(self.tomo_ids)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9b8cb3ca",
   "metadata": {
    "papermill": {
     "duration": 0.003752,
     "end_time": "2025-04-28T00:51:18.086850",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.083098",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# 5. Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "933174e5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.095905Z",
     "iopub.status.busy": "2025-04-28T00:51:18.095336Z",
     "iopub.status.idle": "2025-04-28T00:51:18.101571Z",
     "shell.execute_reply": "2025-04-28T00:51:18.101008Z"
    },
    "papermill": {
     "duration": 0.011951,
     "end_time": "2025-04-28T00:51:18.102738",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.090787",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Simple 3D CNN for motor detection\n",
    "def build_3d_detection_model(input_shape):\n",
    "    \"\"\"Build a 3D CNN model for motor detection\"\"\"\n",
    "    # Start with normalized inputs [0,1]\n",
    "    inputs = layers.Input(shape=input_shape)\n",
    "    \n",
    "    # Encoder - downsampling path\n",
    "    # Block 1\n",
    "    x = layers.Conv3D(16, kernel_size=3, padding='same')(inputs)\n",
    "    x = layers.BatchNormalization()(x)\n",
    "    x = layers.LeakyReLU(alpha=0.1)(x)\n",
    "    x = layers.MaxPooling3D(pool_size=(2, 2, 2))(x)\n",
    "    \n",
    "    # Block 2\n",
    "    x = layers.Conv3D(32, kernel_size=3, padding='same')(x)\n",
    "    x = layers.BatchNormalization()(x)\n",
    "    x = layers.LeakyReLU(alpha=0.1)(x)\n",
    "    x = layers.MaxPooling3D(pool_size=(2, 2, 2))(x)\n",
    "    \n",
    "    # Block 3\n",
    "    x = layers.Conv3D(64, kernel_size=3, padding='same')(x)\n",
    "    x = layers.BatchNormalization()(x)\n",
    "    x = layers.LeakyReLU(alpha=0.1)(x)\n",
    "    x = layers.MaxPooling3D(pool_size=(2, 2, 2))(x)\n",
    "    \n",
    "    # Block 4\n",
    "    x = layers.Conv3D(128, kernel_size=3, padding='same')(x)\n",
    "    x = layers.BatchNormalization()(x)\n",
    "    x = layers.LeakyReLU(alpha=0.1)(x)\n",
    "    x = layers.MaxPooling3D(pool_size=(2, 2, 2))(x)\n",
    "    \n",
    "    # Global features\n",
    "    x = layers.GlobalAveragePooling3D()(x)\n",
    "    x = layers.Dense(128)(x)\n",
    "    x = layers.LeakyReLU(alpha=0.1)(x)\n",
    "    x = layers.Dropout(0.3)(x)\n",
    "    \n",
    "    # Detection head - outputs a flat tensor with 4 values\n",
    "    outputs = layers.Dense(4)(x)\n",
    "    \n",
    "    # Create model\n",
    "    model = tf.keras.Model(inputs=inputs, outputs=outputs)\n",
    "    \n",
    "    return model"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b3568aa2",
   "metadata": {
    "papermill": {
     "duration": 0.003716,
     "end_time": "2025-04-28T00:51:18.110323",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.106607",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# 6. loss function and metrics"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "db7ff14c",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.119179Z",
     "iopub.status.busy": "2025-04-28T00:51:18.118998Z",
     "iopub.status.idle": "2025-04-28T00:51:18.128113Z",
     "shell.execute_reply": "2025-04-28T00:51:18.127604Z"
    },
    "papermill": {
     "duration": 0.014776,
     "end_time": "2025-04-28T00:51:18.129018",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.114242",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Simplified loss function for motor detection with mixed precision handling\n",
    "def motor_detection_loss(y_true, y_pred):\n",
    "    \"\"\"\n",
    "    Custom loss function for 3D motor detection with mixed precision support\n",
    "    \n",
    "    Args:\n",
    "        y_true: Ground truth tensor \n",
    "        y_pred: Predicted tensor\n",
    "        \n",
    "    Returns:\n",
    "        Combined loss value\n",
    "    \"\"\"\n",
    "    # Cast both tensors to same type (float32) to avoid mixed precision issues\n",
    "    y_true = tf.cast(y_true, tf.float32)\n",
    "    y_pred = tf.cast(y_pred, tf.float32)\n",
    "    \n",
    "    # Reshape tensors if needed to ensure consistent shape\n",
    "    y_true = tf.reshape(y_true, [-1, 4])\n",
    "    y_pred = tf.reshape(y_pred, [-1, 4])\n",
    "    \n",
    "    # Split into confidence and coordinates\n",
    "    true_conf = y_true[:, 0:1]  # Shape: [batch_size, 1]\n",
    "    pred_conf = y_pred[:, 0:1]  # Shape: [batch_size, 1]\n",
    "    true_coords = y_true[:, 1:4]  # Shape: [batch_size, 3]\n",
    "    pred_coords = y_pred[:, 1:4]  # Shape: [batch_size, 3]\n",
    "    \n",
    "    # Binary cross-entropy loss for confidence\n",
    "    bce = tf.keras.losses.BinaryCrossentropy(from_logits=False)\n",
    "    conf_loss = bce(true_conf, pred_conf)\n",
    "    \n",
    "    # Mean squared error loss for coordinates, but only when motor exists\n",
    "    # Create a mask for samples with motors\n",
    "    motor_mask = tf.cast(true_conf > 0.5, tf.float32)\n",
    "    \n",
    "    # Compute coordinate loss only for positive samples\n",
    "    coord_error = tf.reduce_sum(tf.square(true_coords - pred_coords), axis=1, keepdims=True)\n",
    "    \n",
    "    # Apply mask and take mean\n",
    "    masked_error = coord_error * motor_mask\n",
    "    coord_loss = tf.reduce_sum(masked_error) / (tf.reduce_sum(motor_mask) + 1e-7)\n",
    "    \n",
    "    # Combine losses with weighting\n",
    "    # Coordinate loss is weighted higher to ensure accurate localization\n",
    "    total_loss = conf_loss + 5.0 * coord_loss\n",
    "    \n",
    "    return total_loss\n",
    "\n",
    "# Custom metrics for training with mixed precision support\n",
    "def detection_accuracy(y_true, y_pred):\n",
    "    \"\"\"Accuracy of motor detection with mixed precision support\"\"\"\n",
    "    # Cast to same type\n",
    "    y_true = tf.cast(y_true, tf.float32)\n",
    "    y_pred = tf.cast(y_pred, tf.float32)\n",
    "    \n",
    "    # Reshape if needed\n",
    "    y_true = tf.reshape(y_true, [-1, 4])\n",
    "    y_pred = tf.reshape(y_pred, [-1, 4])\n",
    "    \n",
    "    # Get confidence values\n",
    "    true_conf = y_true[:, 0]\n",
    "    pred_conf = y_pred[:, 0]\n",
    "    \n",
    "    # Convert to binary predictions\n",
    "    true_positive = tf.cast(true_conf > 0.5, tf.float32)\n",
    "    pred_positive = tf.cast(pred_conf > 0.5, tf.float32)\n",
    "    \n",
    "    # Compute accuracy\n",
    "    correct = tf.cast(tf.equal(true_positive, pred_positive), tf.float32)\n",
    "    accuracy = tf.reduce_mean(correct)\n",
    "    \n",
    "    return accuracy\n",
    "\n",
    "def coordinate_error(y_true, y_pred):\n",
    "    \"\"\"Mean coordinate error for true positives with mixed precision support\"\"\"\n",
    "    # Cast to same type\n",
    "    y_true = tf.cast(y_true, tf.float32)\n",
    "    y_pred = tf.cast(y_pred, tf.float32)\n",
    "    \n",
    "    # Reshape if needed\n",
    "    y_true = tf.reshape(y_true, [-1, 4])\n",
    "    y_pred = tf.reshape(y_pred, [-1, 4])\n",
    "    \n",
    "    # Get confidence and coordinates\n",
    "    true_conf = y_true[:, 0]\n",
    "    pred_conf = y_pred[:, 0]\n",
    "    true_coords = y_true[:, 1:4]\n",
    "    pred_coords = y_pred[:, 1:4]\n",
    "    \n",
    "    # Only compute for true positives\n",
    "    mask = tf.logical_and(true_conf > 0.5, pred_conf > 0.5)\n",
    "    mask = tf.cast(mask, tf.float32)\n",
    "    \n",
    "    # Expand mask for element-wise multiplication\n",
    "    mask_expanded = tf.expand_dims(mask, axis=-1)\n",
    "    mask_expanded = tf.tile(mask_expanded, [1, 3])\n",
    "    \n",
    "    # Apply mask to coordinates before computing difference\n",
    "    masked_true_coords = true_coords * mask_expanded\n",
    "    masked_pred_coords = pred_coords * mask_expanded\n",
    "    \n",
    "    # Calculate squared differences safely\n",
    "    squared_diff = tf.reduce_sum(tf.square(masked_true_coords - masked_pred_coords), axis=1)\n",
    "    \n",
    "    # Mean error over true positives\n",
    "    total_true_pos = tf.reduce_sum(mask) + 1e-7  # Avoid division by zero\n",
    "    mean_error = tf.reduce_sum(tf.sqrt(squared_diff) * mask) / total_true_pos\n",
    "    \n",
    "    return mean_error"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f0623c33",
   "metadata": {
    "papermill": {
     "duration": 0.003749,
     "end_time": "2025-04-28T00:51:18.136580",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.132831",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# 7.  Train model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "b8cdf949",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.145389Z",
     "iopub.status.busy": "2025-04-28T00:51:18.145172Z",
     "iopub.status.idle": "2025-04-28T00:51:18.150864Z",
     "shell.execute_reply": "2025-04-28T00:51:18.150376Z"
    },
    "papermill": {
     "duration": 0.011401,
     "end_time": "2025-04-28T00:51:18.151853",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.140452",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Training function\n",
    "def train_model(train_generator, val_generator, input_shape, epochs=20, \n",
    "                learning_rate=0.001, model_path='best_motor_model.keras'):\n",
    "    \"\"\"Train the motor detection model\"\"\"\n",
    "    # Disable mixed precision globally to avoid type mismatches\n",
    "    tf.keras.mixed_precision.set_global_policy('float32')\n",
    "    \n",
    "    # Create model\n",
    "    model = build_3d_detection_model(input_shape)\n",
    "    \n",
    "    # Use Adam optimizer without dtype parameter\n",
    "    optimizer = Adam(learning_rate=learning_rate)\n",
    "    \n",
    "    # Compile model with custom loss and metrics\n",
    "    model.compile(\n",
    "        optimizer=optimizer,\n",
    "        loss=motor_detection_loss,\n",
    "        metrics=[detection_accuracy, coordinate_error],\n",
    "        # Disable JIT compilation for loss function\n",
    "        jit_compile=False\n",
    "    )\n",
    "    \n",
    "    # Print model summary\n",
    "    model.summary()\n",
    "    \n",
    "    # Callbacks\n",
    "    callbacks = [\n",
    "        # Model checkpoint to save best model\n",
    "        tf.keras.callbacks.ModelCheckpoint(\n",
    "            model_path, \n",
    "            monitor='val_loss',\n",
    "            save_best_only=True,\n",
    "            verbose=1\n",
    "        ),\n",
    "        # Reduce LR on plateau\n",
    "        tf.keras.callbacks.ReduceLROnPlateau(\n",
    "            monitor='val_loss',\n",
    "            factor=0.5,\n",
    "            patience=3,\n",
    "            min_lr=1e-6,\n",
    "            verbose=1\n",
    "        ),\n",
    "        # Early stopping\n",
    "        tf.keras.callbacks.EarlyStopping(\n",
    "            monitor='val_loss',\n",
    "            patience=8,\n",
    "            restore_best_weights=True,\n",
    "            verbose=1\n",
    "        )\n",
    "    ]\n",
    "    \n",
    "    # Train the model\n",
    "    with Timer(\"Model training\"):\n",
    "        history = model.fit(\n",
    "            train_generator,\n",
    "            validation_data=val_generator,\n",
    "            epochs=epochs,\n",
    "            callbacks=callbacks,\n",
    "            verbose=1\n",
    "        )\n",
    "    \n",
    "    # Save final model if it's better than checkpoint\n",
    "    if not os.path.exists(model_path):\n",
    "        model.save(model_path)\n",
    "        print(f\"Final model saved to {model_path}\")\n",
    "    \n",
    "    return model, history"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f6cc78ce",
   "metadata": {
    "papermill": {
     "duration": 0.003751,
     "end_time": "2025-04-28T00:51:18.159894",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.156143",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# 8. inference and predictions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "e2c97a3f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.168843Z",
     "iopub.status.busy": "2025-04-28T00:51:18.168665Z",
     "iopub.status.idle": "2025-04-28T00:51:18.190337Z",
     "shell.execute_reply": "2025-04-28T00:51:18.189621Z"
    },
    "papermill": {
     "duration": 0.027599,
     "end_time": "2025-04-28T00:51:18.191385",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.163786",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# 3D Non-Maximum Suppression\n",
    "def perform_3d_nms(detections, iou_threshold=NMS_IOU_THRESHOLD):\n",
    "    \"\"\"\n",
    "    Perform 3D Non-Maximum Suppression to merge nearby detections\n",
    "    \n",
    "    Args:\n",
    "        detections: List of dictionaries with keys 'z', 'y', 'x', 'confidence'\n",
    "        iou_threshold: Distance threshold for suppression\n",
    "        \n",
    "    Returns:\n",
    "        List of detections after NMS\n",
    "    \"\"\"\n",
    "    if not detections:\n",
    "        return []\n",
    "    \n",
    "    # Sort by confidence (highest first)\n",
    "    detections = sorted(detections, key=lambda x: x['confidence'], reverse=True)\n",
    "    \n",
    "    # List to store final detections after NMS\n",
    "    final_detections = []\n",
    "    \n",
    "    # Define 3D distance function\n",
    "    def distance_3d(d1, d2):\n",
    "        return np.sqrt((d1['z'] - d2['z'])**2 + \n",
    "                      (d1['y'] - d2['y'])**2 + \n",
    "                      (d1['x'] - d2['x'])**2)\n",
    "    \n",
    "    # Maximum distance threshold (based on box size)\n",
    "    box_size = 24  # Approximate motor size\n",
    "    distance_threshold = box_size * iou_threshold\n",
    "    \n",
    "    # Process each detection\n",
    "    while detections:\n",
    "        # Take the detection with highest confidence\n",
    "        best_detection = detections.pop(0)\n",
    "        final_detections.append(best_detection)\n",
    "        \n",
    "        # Filter out detections that are too close to the best detection\n",
    "        detections = [d for d in detections if distance_3d(d, best_detection) > distance_threshold]\n",
    "    \n",
    "    return final_detections\n",
    "\n",
    "# Progressive sampling for efficient inference\n",
    "def progressive_sampling_detection(tomo_id, model, initial_sampling=0.2, max_sampling=0.8):\n",
    "    \"\"\"\n",
    "    Progressive sampling strategy for efficient motor detection in large tomograms\n",
    "    \n",
    "    Args:\n",
    "        tomo_id: Tomogram ID to process\n",
    "        model: Trained detection model\n",
    "        initial_sampling: Initial sampling ratio for coarse scan\n",
    "        max_sampling: Maximum sampling ratio for fine-grained scan\n",
    "        \n",
    "    Returns:\n",
    "        Dictionary with detection results\n",
    "    \"\"\"\n",
    "    print(f\"Processing tomogram {tomo_id} with progressive sampling\")\n",
    "    \n",
    "    # Get all slice files for this tomogram\n",
    "    tomo_dir = os.path.join(TEST_PATH, tomo_id)\n",
    "    all_slices = sorted([f for f in os.listdir(tomo_dir) if f.endswith('.jpg')])\n",
    "    total_slices = len(all_slices)\n",
    "    \n",
    "    print(f\"Found {total_slices} total slices for tomogram {tomo_id}\")\n",
    "    \n",
    "    # STAGE 1: Initial coarse sampling\n",
    "    coarse_count = int(total_slices * initial_sampling)\n",
    "    print(f\"STAGE 1: Performing coarse sampling with {coarse_count} slices ({initial_sampling*100:.1f}%)\")\n",
    "    \n",
    "    # Sample evenly spaced slices for initial scan\n",
    "    coarse_indices = np.linspace(0, total_slices-1, coarse_count, dtype=int)\n",
    "    coarse_slices = [all_slices[i] for i in coarse_indices]\n",
    "    \n",
    "    # In the progressive_sampling_detection function:\n",
    "    coarse_generator = TomogramDataGenerator(\n",
    "        tomo_ids=[tomo_id],\n",
    "        batch_size=1,\n",
    "        slice_sampling_factor=initial_sampling,\n",
    "        max_slices=150,  # Match training value (150)\n",
    "        resize=IMAGE_SIZE,\n",
    "        is_test=True\n",
    "    )\n",
    "    \n",
    "    # Run inference on coarse scan\n",
    "    with Timer(\"Coarse inference\"):\n",
    "        x_batch, _ = coarse_generator[0]\n",
    "        coarse_predictions = model.predict(x_batch, verbose=0)\n",
    "    \n",
    "    # Process coarse predictions\n",
    "    coarse_detections = []\n",
    "    \n",
    "    # Reshape predictions if needed\n",
    "    coarse_predictions = np.reshape(coarse_predictions, (-1, 4))\n",
    "    \n",
    "    # Extract confidence from first element\n",
    "    confidence = coarse_predictions[0, 0]\n",
    "    \n",
    "    if confidence >= CONFIDENCE_THRESHOLD:\n",
    "        # Get coordinates (normalized)\n",
    "        z_norm, y_norm, x_norm = coarse_predictions[0, 1:4]\n",
    "        \n",
    "        # Convert to original coordinates\n",
    "        z = z_norm * total_slices\n",
    "        \n",
    "        # Get the original dimensions from the first slice\n",
    "        sample_path = os.path.join(tomo_dir, all_slices[0])\n",
    "        with Image.open(sample_path) as img:\n",
    "            width, height = img.size\n",
    "        \n",
    "        y = y_norm * height\n",
    "        x = x_norm * width\n",
    "        \n",
    "        # Store detection\n",
    "        coarse_detections.append({\n",
    "            'z': z,\n",
    "            'y': y,\n",
    "            'x': x,\n",
    "            'confidence': float(confidence)\n",
    "        })\n",
    "    \n",
    "    # STAGE 2: Fine-grained sampling if needed\n",
    "    fine_detections = []\n",
    "    if coarse_detections:\n",
    "        print(f\"STAGE 2: Found {len(coarse_detections)} potential detections in coarse scan\")\n",
    "        \n",
    "        # Define region of interest around the detection\n",
    "        z_mean = coarse_detections[0]['z']\n",
    "        z_window = total_slices * 0.2  # 20% of total slices as window\n",
    "        \n",
    "        # Define region bounds\n",
    "        z_min = max(0, int(z_mean - z_window/2))\n",
    "        z_max = min(total_slices, int(z_mean + z_window/2))\n",
    "        \n",
    "        # Calculate how many additional slices to sample\n",
    "        additional_count = int(total_slices * max_sampling) - coarse_count\n",
    "        \n",
    "        if additional_count > 0:\n",
    "            # Sample more densely in the region of interest\n",
    "            region_size = z_max - z_min\n",
    "            fine_indices = np.linspace(z_min, z_max, min(additional_count, region_size), dtype=int)\n",
    "            \n",
    "            # Filter out already processed indices\n",
    "            fine_indices = [i for i in fine_indices if i not in coarse_indices]\n",
    "            fine_slices = [all_slices[i] for i in fine_indices]\n",
    "            \n",
    "            print(f\"Sampling {len(fine_slices)} additional slices in region of interest\")\n",
    "            \n",
    "            # Process each fine slice individually\n",
    "            for i, slice_file in enumerate(fine_slices):\n",
    "                slice_path = os.path.join(tomo_dir, slice_file)\n",
    "                slice_z = int(slice_file.split('_')[1].split('.')[0])\n",
    "                \n",
    "                # Load and preprocess the slice\n",
    "                with Image.open(slice_path) as img:\n",
    "                    if IMAGE_SIZE:\n",
    "                        img = img.resize(IMAGE_SIZE, Image.BICUBIC)\n",
    "                    img_array = np.array(img.convert('L'), dtype=np.float32)\n",
    "                    img_array = enhance_slice(img_array.astype(np.uint8)).astype(np.float32)\n",
    "                    img_array = img_array / 255.0  # Normalize to [0,1]\n",
    "                \n",
    "                # Add batch and channel dimensions\n",
    "                img_tensor = np.expand_dims(np.expand_dims(img_array, axis=0), axis=-1)\n",
    "                \n",
    "                # Create mini-volume for processing\n",
    "                mini_volume = np.zeros((1, 150, IMAGE_SIZE[0], IMAGE_SIZE[1], 1), dtype=np.float32)\n",
    "                # Fill all 150 slices with the same image\n",
    "                for j in range(150):\n",
    "                    mini_volume[0, j, :, :, 0] = img_tensor[0, :, :, 0]\n",
    "                \n",
    "                # Run inference\n",
    "                prediction = model.predict(mini_volume, verbose=0)\n",
    "                prediction = np.reshape(prediction, (-1, 4))\n",
    "                \n",
    "                # Check confidence\n",
    "                confidence = prediction[0, 0]\n",
    "                if confidence >= CONFIDENCE_THRESHOLD * 0.8:  # Lower threshold for fine-grained scan\n",
    "                    # Get normalized coordinates\n",
    "                    _, y_norm, x_norm = prediction[0, 1:4]\n",
    "                    \n",
    "                    # Convert to original coordinates\n",
    "                    y = y_norm * height\n",
    "                    x = x_norm * width\n",
    "                    \n",
    "                    # Store detection with actual slice number\n",
    "                    fine_detections.append({\n",
    "                        'z': slice_z,\n",
    "                        'y': y,\n",
    "                        'x': x,\n",
    "                        'confidence': float(confidence)\n",
    "                    })\n",
    "    else:\n",
    "        print(\"No potential detections found in coarse scan, trying wider search\")\n",
    "        \n",
    "        # If no detections in coarse scan, try sampling more slices\n",
    "        medium_sampling = (initial_sampling + max_sampling) / 2\n",
    "        medium_count = int(total_slices * medium_sampling) - coarse_count\n",
    "        \n",
    "        if medium_count > 0:\n",
    "            # Sample additional slices uniformly\n",
    "            all_indices = set(range(total_slices))\n",
    "            available_indices = list(all_indices - set(coarse_indices))\n",
    "            \n",
    "            # Sort available indices to ensure deterministic behavior\n",
    "            available_indices.sort()\n",
    "            \n",
    "            # Sample systematically\n",
    "            if len(available_indices) > medium_count:\n",
    "                step = len(available_indices) // medium_count\n",
    "                medium_indices = available_indices[::step][:medium_count]\n",
    "            else:\n",
    "                medium_indices = available_indices\n",
    "            \n",
    "            medium_slices = [all_slices[i] for i in medium_indices]\n",
    "            print(f\"Trying {len(medium_slices)} additional slices in medium-resolution scan\")\n",
    "            \n",
    "            # Batch process medium slices\n",
    "            for i in range(0, len(medium_slices), 16):\n",
    "                batch_slices = medium_slices[i:i+16]\n",
    "                batch_paths = [os.path.join(tomo_dir, s) for s in batch_slices]\n",
    "                batch_z = [int(s.split('_')[1].split('.')[0]) for s in batch_slices]\n",
    "                \n",
    "                # Load and preprocess batch\n",
    "                batch_data = []\n",
    "                for path in batch_paths:\n",
    "                    with Image.open(path) as img:\n",
    "                        if IMAGE_SIZE:\n",
    "                            img = img.resize(IMAGE_SIZE, Image.BICUBIC)\n",
    "                        img_array = np.array(img.convert('L'), dtype=np.float32)\n",
    "                        img_array = enhance_slice(img_array.astype(np.uint8)).astype(np.float32)\n",
    "                        img_array = img_array / 255.0  # Normalize to [0,1]\n",
    "                        batch_data.append(img_array)\n",
    "                \n",
    "                # Create mini-volume for batch\n",
    "                batch_length = len(batch_data)\n",
    "                if batch_length < 16:  # Pad if needed\n",
    "                    padding = [batch_data[-1]] * (16 - batch_length)\n",
    "                    batch_data.extend(padding)\n",
    "                \n",
    "                # Create mini-volume properly sized for model\n",
    "                mini_volume = np.zeros((1, 150, IMAGE_SIZE[0], IMAGE_SIZE[1], 1), dtype=np.float32)\n",
    "                \n",
    "                # Choose one representative slice (first one)\n",
    "                reference_slice = batch_data[0]\n",
    "                \n",
    "                # Fill all 150 slices with this reference image\n",
    "                for j in range(150):\n",
    "                    mini_volume[0, j, :, :, 0] = reference_slice\n",
    "                \n",
    "                # Run inference\n",
    "                prediction = model.predict(mini_volume, verbose=0)\n",
    "                prediction = np.reshape(prediction, (-1, 4))\n",
    "                \n",
    "                # Check confidence\n",
    "                confidence = prediction[0, 0]\n",
    "                if confidence >= CONFIDENCE_THRESHOLD * 0.9:  # Even lower threshold for wide scan\n",
    "                    # Get normalized coordinates\n",
    "                    _, y_norm, x_norm = prediction[0, 1:4]\n",
    "                    \n",
    "                    # Convert to original coordinates\n",
    "                    y = y_norm * height\n",
    "                    x = x_norm * width\n",
    "                    \n",
    "                    # Use middle slice as z-coordinate (approximation)\n",
    "                    z_idx = len(batch_z) // 2\n",
    "                    z = batch_z[z_idx] if z_idx < len(batch_z) else batch_z[-1]\n",
    "                    \n",
    "                    # Store detection\n",
    "                    fine_detections.append({\n",
    "                        'z': z,\n",
    "                        'y': y,\n",
    "                        'x': x,\n",
    "                        'confidence': float(confidence)\n",
    "                    })\n",
    "    \n",
    "    # Combine all detections\n",
    "    all_detections = coarse_detections + fine_detections\n",
    "    print(f\"Total detections before NMS: {len(all_detections)}\")\n",
    "    \n",
    "    # Apply 3D NMS\n",
    "    final_detections = perform_3d_nms(all_detections, NMS_IOU_THRESHOLD)\n",
    "    print(f\"Detections after NMS: {len(final_detections)}\")\n",
    "    \n",
    "    # Sort by confidence\n",
    "    final_detections.sort(key=lambda x: x['confidence'], reverse=True)\n",
    "    \n",
    "    # Return coordinates of highest confidence detection, or -1 if none found\n",
    "    if not final_detections:\n",
    "        print(f\"No motor detected in {tomo_id}\")\n",
    "        return {\n",
    "            'tomo_id': tomo_id,\n",
    "            'Motor axis 0': -1,\n",
    "            'Motor axis 1': -1,\n",
    "            'Motor axis 2': -1\n",
    "        }\n",
    "    \n",
    "    # Get best detection\n",
    "    best_detection = final_detections[0]\n",
    "    print(f\"Motor found in {tomo_id} at position: z={best_detection['z']:.1f}, y={best_detection['y']:.1f}, x={best_detection['x']:.1f} with confidence {best_detection['confidence']:.3f}\")\n",
    "    \n",
    "    return {\n",
    "        'tomo_id': tomo_id,\n",
    "        'Motor axis 0': round(best_detection['z']),\n",
    "        'Motor axis 1': round(best_detection['y']),\n",
    "        'Motor axis 2': round(best_detection['x'])\n",
    "    }"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6c0ce189",
   "metadata": {
    "papermill": {
     "duration": 0.003755,
     "end_time": "2025-04-28T00:51:18.198917",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.195162",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# 9. Generate submission"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "975537d0",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.207847Z",
     "iopub.status.busy": "2025-04-28T00:51:18.207642Z",
     "iopub.status.idle": "2025-04-28T00:51:18.217333Z",
     "shell.execute_reply": "2025-04-28T00:51:18.216655Z"
    },
    "papermill": {
     "duration": 0.015338,
     "end_time": "2025-04-28T00:51:18.218351",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.203013",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def generate_submission():\n",
    "    \"\"\"Generate submission file using trained model and progressive sampling\"\"\"\n",
    "    # Get list of test tomograms\n",
    "    test_tomos = sorted([d for d in os.listdir(TEST_PATH) if os.path.isdir(os.path.join(TEST_PATH, d))])\n",
    "    total_tomos = len(test_tomos)\n",
    "    \n",
    "    print(f\"Found {total_tomos} tomograms in test directory\")\n",
    "    \n",
    "    # Load model\n",
    "    model = None\n",
    "    model_path = '/kaggle/working/best_motor_model.keras'\n",
    "    \n",
    "    if os.path.exists(model_path):\n",
    "        print(f\"Loading model from {model_path}\")\n",
    "        model = tf.keras.models.load_model(\n",
    "            model_path,\n",
    "            custom_objects={\n",
    "                'motor_detection_loss': motor_detection_loss,\n",
    "                'detection_accuracy': detection_accuracy,\n",
    "                'coordinate_error': coordinate_error\n",
    "            }\n",
    "        )\n",
    "    else:\n",
    "        print(\"Model not found, please train the model first\")\n",
    "        return None\n",
    "    \n",
    "    # Process tomograms with ThreadPoolExecutor for parallelization\n",
    "    results = []\n",
    "    motors_found = 0\n",
    "    \n",
    "    # Process each tomogram\n",
    "    for i, tomo_id in enumerate(test_tomos, 1):\n",
    "        print(f\"\\nProcessing tomogram {i}/{total_tomos}: {tomo_id}\")\n",
    "        \n",
    "        try:\n",
    "            # Clear memory before processing\n",
    "            clear_memory()\n",
    "            \n",
    "            # Process tomogram with progressive sampling\n",
    "            result = progressive_sampling_detection(tomo_id, model)\n",
    "            results.append(result)\n",
    "            \n",
    "            # Update motors found count\n",
    "            has_motor = result['Motor axis 0'] >= 0\n",
    "            if has_motor:\n",
    "                motors_found += 1\n",
    "                print(f\"Motor found in {tomo_id} at position: \"\n",
    "                      f\"z={result['Motor axis 0']}, y={result['Motor axis 1']}, x={result['Motor axis 2']}\")\n",
    "            else:\n",
    "                print(f\"No motor detected in {tomo_id}\")\n",
    "                \n",
    "            print(f\"Current detection rate: {motors_found}/{i} ({motors_found/i*100:.1f}%)\")\n",
    "            \n",
    "        except Exception as e:\n",
    "            print(f\"Error processing {tomo_id}: {e}\")\n",
    "            # Create a default entry for failed tomograms\n",
    "            results.append({\n",
    "                'tomo_id': tomo_id,\n",
    "                'Motor axis 0': -1,\n",
    "                'Motor axis 1': -1,\n",
    "                'Motor axis 2': -1\n",
    "            })\n",
    "    \n",
    "    # Create submission dataframe\n",
    "    submission_df = pd.DataFrame(results)\n",
    "    \n",
    "    # Ensure proper column order\n",
    "    submission_df = submission_df[['tomo_id', 'Motor axis 0', 'Motor axis 1', 'Motor axis 2']]\n",
    "    \n",
    "    # Save the submission file\n",
    "    submission_df.to_csv(SUBMISSION_PATH, index=False)\n",
    "    \n",
    "    print(f\"\\nSubmission complete!\")\n",
    "    print(f\"Motors detected: {motors_found}/{total_tomos} ({motors_found/total_tomos*100:.1f}%)\")\n",
    "    print(f\"Submission saved to: {SUBMISSION_PATH}\")\n",
    "    \n",
    "    # Display first few rows of submission\n",
    "    print(\"\\nSubmission preview:\")\n",
    "    print(submission_df.head())\n",
    "    \n",
    "    return submission_df\n",
    "\n",
    "# Plot training history\n",
    "def plot_training_history(history):\n",
    "    \"\"\"Plot training and validation metrics\"\"\"\n",
    "    plt.figure(figsize=(15, 5))\n",
    "    \n",
    "    # Plot loss\n",
    "    plt.subplot(1, 3, 1)\n",
    "    plt.plot(history.history['loss'], label='Train Loss')\n",
    "    plt.plot(history.history['val_loss'], label='Val Loss')\n",
    "    plt.title('Training and Validation Loss')\n",
    "    plt.xlabel('Epoch')\n",
    "    plt.ylabel('Loss')\n",
    "    plt.legend()\n",
    "    \n",
    "    # Plot detection accuracy\n",
    "    plt.subplot(1, 3, 2)\n",
    "    plt.plot(history.history['detection_accuracy'], label='Train Accuracy')\n",
    "    plt.plot(history.history['val_detection_accuracy'], label='Val Accuracy')\n",
    "    plt.title('Detection Accuracy')\n",
    "    plt.xlabel('Epoch')\n",
    "    plt.ylabel('Accuracy')\n",
    "    plt.legend()\n",
    "    \n",
    "    # Plot coordinate error\n",
    "    plt.subplot(1, 3, 3)\n",
    "    plt.plot(history.history['coordinate_error'], label='Train Coord Error')\n",
    "    plt.plot(history.history['val_coordinate_error'], label='Val Coord Error')\n",
    "    plt.title('Coordinate Error')\n",
    "    plt.xlabel('Epoch')\n",
    "    plt.ylabel('Error')\n",
    "    plt.legend()\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.savefig('training_history.png')\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2914e5b3",
   "metadata": {
    "papermill": {
     "duration": 0.003684,
     "end_time": "2025-04-28T00:51:18.225779",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.222095",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# 10. optional visulatiztion function"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "3ab9847e",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.234346Z",
     "iopub.status.busy": "2025-04-28T00:51:18.234116Z",
     "iopub.status.idle": "2025-04-28T00:51:18.240379Z",
     "shell.execute_reply": "2025-04-28T00:51:18.239722Z"
    },
    "papermill": {
     "duration": 0.011799,
     "end_time": "2025-04-28T00:51:18.241490",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.229691",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def visualize_detections(tomo_id, detection_result):\n",
    "    \"\"\"Visualize detection result for a tomogram\"\"\"\n",
    "    # Skip if no motor detected\n",
    "    if detection_result['Motor axis 0'] < 0:\n",
    "        print(f\"No motor detected in {tomo_id}\")\n",
    "        return\n",
    "    \n",
    "    # Get tomogram folder\n",
    "    tomo_dir = os.path.join(TEST_PATH, tomo_id)\n",
    "    \n",
    "    # Get detected motor coordinates\n",
    "    z = detection_result['Motor axis 0']\n",
    "    y = detection_result['Motor axis 1']\n",
    "    x = detection_result['Motor axis 2']\n",
    "    \n",
    "    # Get all slice files\n",
    "    slice_files = sorted([f for f in os.listdir(tomo_dir) if f.endswith('.jpg')])\n",
    "    \n",
    "    # Find the slice corresponding to the z-coordinate\n",
    "    if 0 <= z < len(slice_files):\n",
    "        slice_file = slice_files[z]\n",
    "        slice_path = os.path.join(tomo_dir, slice_file)\n",
    "        \n",
    "        # Load the slice\n",
    "        img = np.array(Image.open(slice_path))\n",
    "        \n",
    "        # Create figure\n",
    "        plt.figure(figsize=(12, 10))\n",
    "        \n",
    "        # Show the slice\n",
    "        plt.imshow(img, cmap='gray')\n",
    "        \n",
    "        # Mark the detected position\n",
    "        plt.plot(x, y, 'ro', markersize=10)\n",
    "        \n",
    "        # Add a bounding box around the motor\n",
    "        box_size = 24\n",
    "        rect = plt.Rectangle((x - box_size//2, y - box_size//2), box_size, box_size,\n",
    "                             linewidth=2, edgecolor='r', facecolor='none')\n",
    "        plt.gca().add_patch(rect)\n",
    "        \n",
    "        # Add annotation\n",
    "        plt.annotate(f\"Motor\", (x + box_size//2 + 5, y),\n",
    "                    color='red', fontsize=12)\n",
    "        \n",
    "        plt.title(f\"Motor detected in {tomo_id} at position: z={z}, y={y}, x={x}\")\n",
    "        \n",
    "        # Save the visualization\n",
    "        plt.tight_layout()\n",
    "        plt.savefig(f\"{tomo_id}_detection.png\")\n",
    "        plt.show()\n",
    "    else:\n",
    "        print(f\"Invalid z-coordinate {z} for tomogram {tomo_id}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "12256e1c",
   "metadata": {
    "papermill": {
     "duration": 0.003582,
     "end_time": "2025-04-28T00:51:18.249028",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.245446",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Main pipeline"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "8597e731",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.257570Z",
     "iopub.status.busy": "2025-04-28T00:51:18.257391Z",
     "iopub.status.idle": "2025-04-28T00:51:18.263719Z",
     "shell.execute_reply": "2025-04-28T00:51:18.263196Z"
    },
    "papermill": {
     "duration": 0.011868,
     "end_time": "2025-04-28T00:51:18.264680",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.252812",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "def run_pipeline():\n",
    "    \"\"\"Run the full motor detection pipeline\"\"\"\n",
    "    start_time = time.time()\n",
    "    print(\"Starting BYU Flagellar Motor Detection Pipeline\")\n",
    "    \n",
    "    # Set up GPU and get batch size\n",
    "    batch_size, has_gpu = optimize_gpu()\n",
    "    \n",
    "    # Load training labels\n",
    "    train_labels_df = pd.read_csv(TRAIN_LABELS)\n",
    "    print(f\"Loaded {len(train_labels_df)} training labels\")\n",
    "    \n",
    "    # Split data into train and validation sets\n",
    "    train_ids, val_ids = create_train_val_split(train_labels_df, val_fraction=0.2)\n",
    "    print(f\"Training on {len(train_ids)} tomograms, validating on {len(val_ids)} tomograms\")\n",
    "    \n",
    "    # Create data generators\n",
    "    train_generator = TomogramDataGenerator(\n",
    "        tomo_ids=train_ids,\n",
    "        labels_df=train_labels_df,\n",
    "        batch_size=batch_size,\n",
    "        shuffle=True,\n",
    "        slice_sampling_factor=0.5,\n",
    "        max_slices=150,\n",
    "        resize=IMAGE_SIZE,\n",
    "        augment=True\n",
    "    )\n",
    "    \n",
    "    val_generator = TomogramDataGenerator(\n",
    "        tomo_ids=val_ids,\n",
    "        labels_df=train_labels_df,\n",
    "        batch_size=batch_size,\n",
    "        shuffle=False,\n",
    "        slice_sampling_factor=0.5,\n",
    "        max_slices=150,\n",
    "        resize=IMAGE_SIZE,\n",
    "        augment=False\n",
    "    )\n",
    "    \n",
    "    # Get input shape from generator\n",
    "    with Timer(\"Loading sample batch\"):\n",
    "        sample_batch, _ = train_generator[0]\n",
    "    \n",
    "    input_shape = sample_batch.shape[1:]\n",
    "    print(f\"Model input shape: {input_shape}\")\n",
    "    \n",
    "    # Check if model exists\n",
    "    model_path = '/kaggle/working/best_motor_model.keras'\n",
    "    \n",
    "    if os.path.exists(model_path):\n",
    "        print(f\"Loading existing model from {model_path}\")\n",
    "        model = tf.keras.models.load_model(\n",
    "            model_path,\n",
    "            custom_objects={\n",
    "                'motor_detection_loss': motor_detection_loss,\n",
    "                'detection_accuracy': detection_accuracy,\n",
    "                'coordinate_error': coordinate_error\n",
    "            }\n",
    "        )\n",
    "    else:\n",
    "        print(\"Training new model\")\n",
    "        \n",
    "        # Train model\n",
    "        model, history = train_model(\n",
    "            train_generator,\n",
    "            val_generator,\n",
    "            input_shape,\n",
    "            epochs=15,\n",
    "            learning_rate=0.001,\n",
    "            model_path=model_path\n",
    "        )\n",
    "        \n",
    "        #Plot Training\n",
    "        plot_training_history(history)\n",
    "    \n",
    "    # Clear memory before inference\n",
    "    clear_memory()\n",
    "    \n",
    "    # Generate submission\n",
    "    print(\"\\nGenerating submission\")\n",
    "    submission_df = generate_submission()\n",
    "    \n",
    "    # Print total execution time\n",
    "    elapsed = time.time() - start_time\n",
    "    print(f\"\\nTotal execution time: {elapsed:.2f} seconds ({elapsed/60:.2f} minutes)\")\n",
    "    \n",
    "    return submission_df"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9c4f4a91",
   "metadata": {
    "papermill": {
     "duration": 0.003658,
     "end_time": "2025-04-28T00:51:18.272207",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.268549",
     "status": "completed"
    },
    "tags": []
   },
   "source": [
    "# Run scripts"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "7f4e8e91",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T00:51:18.280782Z",
     "iopub.status.busy": "2025-04-28T00:51:18.280381Z",
     "iopub.status.idle": "2025-04-28T10:56:33.606008Z",
     "shell.execute_reply": "2025-04-28T10:56:33.605136Z"
    },
    "papermill": {
     "duration": 36315.331469,
     "end_time": "2025-04-28T10:56:33.607502",
     "exception": false,
     "start_time": "2025-04-28T00:51:18.276033",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting BYU Flagellar Motor Detection Pipeline\n",
      "Found 2 GPU(s)\n",
      "Memory growth enabled for PhysicalDevice(name='/physical_device:GPU:0', device_type='GPU')\n",
      "Memory growth enabled for PhysicalDevice(name='/physical_device:GPU:1', device_type='GPU')\n",
      "Using explicit type casting for mixed precision operations\n",
      "XLA JIT compilation enabled\n",
      "Loaded 737 training labels\n",
      "Training on 518 tomograms, validating on 130 tomograms\n",
      "[TIMER] Loading sample batch: 24.479s\n",
      "Model input shape: (150, 224, 224, 1)\n",
      "Training new model\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "I0000 00:00:1745801504.285842      20 gpu_device.cc:2022] Created device /job:localhost/replica:0/task:0/device:GPU:0 with 13942 MB memory:  -> device: 0, name: Tesla T4, pci bus id: 0000:00:04.0, compute capability: 7.5\n",
      "I0000 00:00:1745801504.286478      20 gpu_device.cc:2022] Created device /job:localhost/replica:0/task:0/device:GPU:1 with 13942 MB memory:  -> device: 1, name: Tesla T4, pci bus id: 0000:00:05.0, compute capability: 7.5\n",
      "/usr/local/lib/python3.11/dist-packages/keras/src/layers/activations/leaky_relu.py:41: UserWarning: Argument `alpha` is deprecated. Use `negative_slope` instead.\n",
      "  warnings.warn(\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\"><span style=\"font-weight: bold\">Model: \"functional\"</span>\n",
       "</pre>\n"
      ],
      "text/plain": [
       "\u001b[1mModel: \"functional\"\u001b[0m\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\">\n",
       "<span style=\"font-weight: bold\"> Layer (type)                         </span><span style=\"font-weight: bold\"> Output Shape                </span><span style=\"font-weight: bold\">         Param # </span>\n",
       "\n",
       " input_layer (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">InputLayer</span>)              (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">150</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">224</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">224</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">1</span>)                   <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " conv3d (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Conv3D</span>)                       (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">150</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">224</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">224</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">16</span>)                <span style=\"color: #00af00; text-decoration-color: #00af00\">448</span> \n",
       "\n",
       " batch_normalization                   (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">150</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">224</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">224</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">16</span>)                 <span style=\"color: #00af00; text-decoration-color: #00af00\">64</span> \n",
       " (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">BatchNormalization</span>)                                                               \n",
       "\n",
       " leaky_re_lu (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">LeakyReLU</span>)               (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">150</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">224</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">224</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">16</span>)                  <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " max_pooling3d (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">MaxPooling3D</span>)          (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">75</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">112</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">112</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">16</span>)                   <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " conv3d_1 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Conv3D</span>)                     (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">75</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">112</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">112</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">32</span>)              <span style=\"color: #00af00; text-decoration-color: #00af00\">13,856</span> \n",
       "\n",
       " batch_normalization_1                 (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">75</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">112</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">112</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">32</span>)                 <span style=\"color: #00af00; text-decoration-color: #00af00\">128</span> \n",
       " (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">BatchNormalization</span>)                                                               \n",
       "\n",
       " leaky_re_lu_1 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">LeakyReLU</span>)             (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">75</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">112</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">112</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">32</span>)                   <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " max_pooling3d_1 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">MaxPooling3D</span>)        (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">37</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">56</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">56</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">32</span>)                     <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " conv3d_2 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Conv3D</span>)                     (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">37</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">56</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">56</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">64</span>)                <span style=\"color: #00af00; text-decoration-color: #00af00\">55,360</span> \n",
       "\n",
       " batch_normalization_2                 (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">37</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">56</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">56</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">64</span>)                   <span style=\"color: #00af00; text-decoration-color: #00af00\">256</span> \n",
       " (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">BatchNormalization</span>)                                                               \n",
       "\n",
       " leaky_re_lu_2 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">LeakyReLU</span>)             (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">37</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">56</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">56</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">64</span>)                     <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " max_pooling3d_2 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">MaxPooling3D</span>)        (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">18</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">28</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">28</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">64</span>)                     <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " conv3d_3 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Conv3D</span>)                     (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">18</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">28</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">28</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">128</span>)              <span style=\"color: #00af00; text-decoration-color: #00af00\">221,312</span> \n",
       "\n",
       " batch_normalization_3                 (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">18</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">28</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">28</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">128</span>)                  <span style=\"color: #00af00; text-decoration-color: #00af00\">512</span> \n",
       " (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">BatchNormalization</span>)                                                               \n",
       "\n",
       " leaky_re_lu_3 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">LeakyReLU</span>)             (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">18</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">28</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">28</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">128</span>)                    <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " max_pooling3d_3 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">MaxPooling3D</span>)        (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">9</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">14</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">14</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">128</span>)                     <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " global_average_pooling3d              (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">128</span>)                                <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       " (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">GlobalAveragePooling3D</span>)                                                           \n",
       "\n",
       " dense (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Dense</span>)                         (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">128</span>)                           <span style=\"color: #00af00; text-decoration-color: #00af00\">16,512</span> \n",
       "\n",
       " leaky_re_lu_4 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">LeakyReLU</span>)             (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">128</span>)                                <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " dropout (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Dropout</span>)                     (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">128</span>)                                <span style=\"color: #00af00; text-decoration-color: #00af00\">0</span> \n",
       "\n",
       " dense_1 (<span style=\"color: #0087ff; text-decoration-color: #0087ff\">Dense</span>)                       (<span style=\"color: #00d7ff; text-decoration-color: #00d7ff\">None</span>, <span style=\"color: #00af00; text-decoration-color: #00af00\">4</span>)                                <span style=\"color: #00af00; text-decoration-color: #00af00\">516</span> \n",
       "\n",
       "</pre>\n"
      ],
      "text/plain": [
       "\n",
       "\u001b[1m \u001b[0m\u001b[1mLayer (type)                        \u001b[0m\u001b[1m \u001b[0m\u001b[1m \u001b[0m\u001b[1mOutput Shape               \u001b[0m\u001b[1m \u001b[0m\u001b[1m \u001b[0m\u001b[1m        Param #\u001b[0m\u001b[1m \u001b[0m\n",
       "\n",
       " input_layer (\u001b[38;5;33mInputLayer\u001b[0m)              (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m150\u001b[0m, \u001b[38;5;34m224\u001b[0m, \u001b[38;5;34m224\u001b[0m, \u001b[38;5;34m1\u001b[0m)                   \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " conv3d (\u001b[38;5;33mConv3D\u001b[0m)                       (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m150\u001b[0m, \u001b[38;5;34m224\u001b[0m, \u001b[38;5;34m224\u001b[0m, \u001b[38;5;34m16\u001b[0m)                \u001b[38;5;34m448\u001b[0m \n",
       "\n",
       " batch_normalization                   (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m150\u001b[0m, \u001b[38;5;34m224\u001b[0m, \u001b[38;5;34m224\u001b[0m, \u001b[38;5;34m16\u001b[0m)                 \u001b[38;5;34m64\u001b[0m \n",
       " (\u001b[38;5;33mBatchNormalization\u001b[0m)                                                               \n",
       "\n",
       " leaky_re_lu (\u001b[38;5;33mLeakyReLU\u001b[0m)               (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m150\u001b[0m, \u001b[38;5;34m224\u001b[0m, \u001b[38;5;34m224\u001b[0m, \u001b[38;5;34m16\u001b[0m)                  \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " max_pooling3d (\u001b[38;5;33mMaxPooling3D\u001b[0m)          (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m75\u001b[0m, \u001b[38;5;34m112\u001b[0m, \u001b[38;5;34m112\u001b[0m, \u001b[38;5;34m16\u001b[0m)                   \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " conv3d_1 (\u001b[38;5;33mConv3D\u001b[0m)                     (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m75\u001b[0m, \u001b[38;5;34m112\u001b[0m, \u001b[38;5;34m112\u001b[0m, \u001b[38;5;34m32\u001b[0m)              \u001b[38;5;34m13,856\u001b[0m \n",
       "\n",
       " batch_normalization_1                 (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m75\u001b[0m, \u001b[38;5;34m112\u001b[0m, \u001b[38;5;34m112\u001b[0m, \u001b[38;5;34m32\u001b[0m)                 \u001b[38;5;34m128\u001b[0m \n",
       " (\u001b[38;5;33mBatchNormalization\u001b[0m)                                                               \n",
       "\n",
       " leaky_re_lu_1 (\u001b[38;5;33mLeakyReLU\u001b[0m)             (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m75\u001b[0m, \u001b[38;5;34m112\u001b[0m, \u001b[38;5;34m112\u001b[0m, \u001b[38;5;34m32\u001b[0m)                   \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " max_pooling3d_1 (\u001b[38;5;33mMaxPooling3D\u001b[0m)        (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m37\u001b[0m, \u001b[38;5;34m56\u001b[0m, \u001b[38;5;34m56\u001b[0m, \u001b[38;5;34m32\u001b[0m)                     \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " conv3d_2 (\u001b[38;5;33mConv3D\u001b[0m)                     (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m37\u001b[0m, \u001b[38;5;34m56\u001b[0m, \u001b[38;5;34m56\u001b[0m, \u001b[38;5;34m64\u001b[0m)                \u001b[38;5;34m55,360\u001b[0m \n",
       "\n",
       " batch_normalization_2                 (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m37\u001b[0m, \u001b[38;5;34m56\u001b[0m, \u001b[38;5;34m56\u001b[0m, \u001b[38;5;34m64\u001b[0m)                   \u001b[38;5;34m256\u001b[0m \n",
       " (\u001b[38;5;33mBatchNormalization\u001b[0m)                                                               \n",
       "\n",
       " leaky_re_lu_2 (\u001b[38;5;33mLeakyReLU\u001b[0m)             (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m37\u001b[0m, \u001b[38;5;34m56\u001b[0m, \u001b[38;5;34m56\u001b[0m, \u001b[38;5;34m64\u001b[0m)                     \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " max_pooling3d_2 (\u001b[38;5;33mMaxPooling3D\u001b[0m)        (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m18\u001b[0m, \u001b[38;5;34m28\u001b[0m, \u001b[38;5;34m28\u001b[0m, \u001b[38;5;34m64\u001b[0m)                     \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " conv3d_3 (\u001b[38;5;33mConv3D\u001b[0m)                     (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m18\u001b[0m, \u001b[38;5;34m28\u001b[0m, \u001b[38;5;34m28\u001b[0m, \u001b[38;5;34m128\u001b[0m)              \u001b[38;5;34m221,312\u001b[0m \n",
       "\n",
       " batch_normalization_3                 (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m18\u001b[0m, \u001b[38;5;34m28\u001b[0m, \u001b[38;5;34m28\u001b[0m, \u001b[38;5;34m128\u001b[0m)                  \u001b[38;5;34m512\u001b[0m \n",
       " (\u001b[38;5;33mBatchNormalization\u001b[0m)                                                               \n",
       "\n",
       " leaky_re_lu_3 (\u001b[38;5;33mLeakyReLU\u001b[0m)             (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m18\u001b[0m, \u001b[38;5;34m28\u001b[0m, \u001b[38;5;34m28\u001b[0m, \u001b[38;5;34m128\u001b[0m)                    \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " max_pooling3d_3 (\u001b[38;5;33mMaxPooling3D\u001b[0m)        (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m9\u001b[0m, \u001b[38;5;34m14\u001b[0m, \u001b[38;5;34m14\u001b[0m, \u001b[38;5;34m128\u001b[0m)                     \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " global_average_pooling3d              (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m128\u001b[0m)                                \u001b[38;5;34m0\u001b[0m \n",
       " (\u001b[38;5;33mGlobalAveragePooling3D\u001b[0m)                                                           \n",
       "\n",
       " dense (\u001b[38;5;33mDense\u001b[0m)                         (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m128\u001b[0m)                           \u001b[38;5;34m16,512\u001b[0m \n",
       "\n",
       " leaky_re_lu_4 (\u001b[38;5;33mLeakyReLU\u001b[0m)             (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m128\u001b[0m)                                \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " dropout (\u001b[38;5;33mDropout\u001b[0m)                     (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m128\u001b[0m)                                \u001b[38;5;34m0\u001b[0m \n",
       "\n",
       " dense_1 (\u001b[38;5;33mDense\u001b[0m)                       (\u001b[38;5;45mNone\u001b[0m, \u001b[38;5;34m4\u001b[0m)                                \u001b[38;5;34m516\u001b[0m \n",
       "\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\"><span style=\"font-weight: bold\"> Total params: </span><span style=\"color: #00af00; text-decoration-color: #00af00\">308,964</span> (1.18 MB)\n",
       "</pre>\n"
      ],
      "text/plain": [
       "\u001b[1m Total params: \u001b[0m\u001b[38;5;34m308,964\u001b[0m (1.18 MB)\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\"><span style=\"font-weight: bold\"> Trainable params: </span><span style=\"color: #00af00; text-decoration-color: #00af00\">308,484</span> (1.18 MB)\n",
       "</pre>\n"
      ],
      "text/plain": [
       "\u001b[1m Trainable params: \u001b[0m\u001b[38;5;34m308,484\u001b[0m (1.18 MB)\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<pre style=\"white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace\"><span style=\"font-weight: bold\"> Non-trainable params: </span><span style=\"color: #00af00; text-decoration-color: #00af00\">480</span> (1.88 KB)\n",
       "</pre>\n"
      ],
      "text/plain": [
       "\u001b[1m Non-trainable params: \u001b[0m\u001b[38;5;34m480\u001b[0m (1.88 KB)\n"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 1/15\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "WARNING: All log messages before absl::InitializeLog() is called are written to STDERR\n",
      "I0000 00:00:1745801552.913021      66 service.cc:148] XLA service 0x7efd2c003ae0 initialized for platform CUDA (this does not guarantee that XLA will be used). Devices:\n",
      "I0000 00:00:1745801552.913719      66 service.cc:156]   StreamExecutor device (0): Tesla T4, Compute Capability 7.5\n",
      "I0000 00:00:1745801552.913739      66 service.cc:156]   StreamExecutor device (1): Tesla T4, Compute Capability 7.5\n",
      "I0000 00:00:1745801552.941697      66 cuda_dnn.cc:529] Loaded cuDNN version 90300\n",
      "I0000 00:00:1745801553.021870      66 device_compiler.h:188] Compiled cluster using XLA!  This line is logged at most once for the lifetime of the process.\n",
      "/usr/local/lib/python3.11/dist-packages/keras/src/trainers/data_adapters/py_dataset_adapter.py:122: UserWarning: Your `PyDataset` class should call `super().__init__(**kwargs)` in its constructor. `**kwargs` can include `workers`, `use_multiprocessing`, `max_queue_size`. Do not pass these arguments to `fit()`, as they will be ignored.\n",
      "  self._warn_if_super_not_called()\n",
      "E0000 00:00:1745801766.178148      67 gpu_timer.cc:82] Delay kernel timed out: measured time has sub-optimal accuracy. There may be a missing warmup execution, please investigate in Nsight Systems.\n",
      "E0000 00:00:1745801766.487580      67 gpu_timer.cc:82] Delay kernel timed out: measured time has sub-optimal accuracy. There may be a missing warmup execution, please investigate in Nsight Systems.\n",
      "2025-04-28 00:56:08.944821: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng0{} for conv (f32[6,32,75,112,112]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,16,75,112,112]{4,3,2,1,0}, f32[32,16,3,3,3]{4,3,2,1,0}, f32[32]{0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBiasActivationForward\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:09.669973: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 1.725240729s\n",
      "Trying algorithm eng0{} for conv (f32[6,32,75,112,112]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,16,75,112,112]{4,3,2,1,0}, f32[32,16,3,3,3]{4,3,2,1,0}, f32[32]{0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBiasActivationForward\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:16.265829: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng0{} for conv (f32[6,16,75,112,112]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,32,75,112,112]{4,3,2,1,0}, f32[32,16,3,3,3]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardInput\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:16.916906: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 1.651161755s\n",
      "Trying algorithm eng0{} for conv (f32[6,16,75,112,112]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,32,75,112,112]{4,3,2,1,0}, f32[32,16,3,3,3]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardInput\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:18.459860: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng20{k2=6,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,1,150,224,224]{4,3,2,1,0}, f32[6,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:20.024675: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 2.564904195s\n",
      "Trying algorithm eng20{k2=6,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,1,150,224,224]{4,3,2,1,0}, f32[6,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:21.024894: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng20{k2=5,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,1,150,224,224]{4,3,2,1,0}, f32[6,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:23.884701: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 3.859912138s\n",
      "Trying algorithm eng20{k2=5,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,1,150,224,224]{4,3,2,1,0}, f32[6,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:24.884912: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng20{k2=8,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,1,150,224,224]{4,3,2,1,0}, f32[6,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:27.969774: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 4.084954032s\n",
      "Trying algorithm eng20{k2=8,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,1,150,224,224]{4,3,2,1,0}, f32[6,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:28.969966: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng0{} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,1,150,224,224]{4,3,2,1,0}, f32[6,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:29.398604: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 1.428719276s\n",
      "Trying algorithm eng0{} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,1,150,224,224]{4,3,2,1,0}, f32[6,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:33.368307: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng20{k2=1,k3=0} for conv (f32[32,16,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,16,75,112,112]{4,3,2,1,0}, f32[6,32,75,112,112]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:33.823982: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 1.455763847s\n",
      "Trying algorithm eng20{k2=1,k3=0} for conv (f32[32,16,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,16,75,112,112]{4,3,2,1,0}, f32[6,32,75,112,112]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:34.824183: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng0{} for conv (f32[32,16,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,16,75,112,112]{4,3,2,1,0}, f32[6,32,75,112,112]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 00:56:41.613998: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 7.789915403s\n",
      "Trying algorithm eng0{} for conv (f32[32,16,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[6,16,75,112,112]{4,3,2,1,0}, f32[6,32,75,112,112]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 23s/step - coordinate_error: 0.4895 - detection_accuracy: 0.6542 - loss: 8.3736 \n",
      "Epoch 1: val_loss improved from inf to 8.38780, saving model to /kaggle/working/best_motor_model.keras\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2818s\u001b[0m 30s/step - coordinate_error: 0.4900 - detection_accuracy: 0.6545 - loss: 8.3517 - val_coordinate_error: 0.4231 - val_detection_accuracy: 0.5341 - val_loss: 8.3878 - learning_rate: 0.0010\n",
      "Epoch 2/15\n",
      "\u001b[1m38/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m17:45\u001b[0m 22s/step - coordinate_error: 0.5775 - detection_accuracy: 0.6509 - loss: 6.3149"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "E0000 00:00:1745805365.209388      66 gpu_timer.cc:82] Delay kernel timed out: measured time has sub-optimal accuracy. There may be a missing warmup execution, please investigate in Nsight Systems.\n",
      "E0000 00:00:1745805365.423876      66 gpu_timer.cc:82] Delay kernel timed out: measured time has sub-optimal accuracy. There may be a missing warmup execution, please investigate in Nsight Systems.\n",
      "2025-04-28 01:56:12.016755: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng20{k2=6,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[2,1,150,224,224]{4,3,2,1,0}, f32[2,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 01:56:13.568162: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 2.551492898s\n",
      "Trying algorithm eng20{k2=6,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[2,1,150,224,224]{4,3,2,1,0}, f32[2,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 01:56:14.568337: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng20{k2=5,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[2,1,150,224,224]{4,3,2,1,0}, f32[2,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 01:56:17.420551: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 3.852269579s\n",
      "Trying algorithm eng20{k2=5,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[2,1,150,224,224]{4,3,2,1,0}, f32[2,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 01:56:18.420770: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng20{k2=8,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[2,1,150,224,224]{4,3,2,1,0}, f32[2,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 01:56:21.509850: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 4.089181492s\n",
      "Trying algorithm eng20{k2=8,k3=0} for conv (f32[16,1,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[2,1,150,224,224]{4,3,2,1,0}, f32[2,16,150,224,224]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 01:56:25.707313: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng0{} for conv (f32[32,16,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[2,16,75,112,112]{4,3,2,1,0}, f32[2,32,75,112,112]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 01:56:29.361900: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 4.654622684s\n",
      "Trying algorithm eng0{} for conv (f32[32,16,3,3,3]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[2,16,75,112,112]{4,3,2,1,0}, f32[2,32,75,112,112]{4,3,2,1,0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBackwardFilter\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 21s/step - coordinate_error: 0.5127 - detection_accuracy: 0.6641 - loss: 5.3592 "
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "E0000 00:00:1745806876.157583      66 gpu_timer.cc:82] Delay kernel timed out: measured time has sub-optimal accuracy. There may be a missing warmup execution, please investigate in Nsight Systems.\n",
      "E0000 00:00:1745806876.431626      66 gpu_timer.cc:82] Delay kernel timed out: measured time has sub-optimal accuracy. There may be a missing warmup execution, please investigate in Nsight Systems.\n",
      "2025-04-28 02:21:18.690646: E external/local_xla/xla/service/slow_operation_alarm.cc:65] Trying algorithm eng0{} for conv (f32[4,32,75,112,112]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[4,16,75,112,112]{4,3,2,1,0}, f32[32,16,3,3,3]{4,3,2,1,0}, f32[32]{0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBiasActivationForward\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n",
      "2025-04-28 02:21:19.032270: E external/local_xla/xla/service/slow_operation_alarm.cc:133] The operation took 1.341718792s\n",
      "Trying algorithm eng0{} for conv (f32[4,32,75,112,112]{4,3,2,1,0}, u8[0]{0}) custom-call(f32[4,16,75,112,112]{4,3,2,1,0}, f32[32,16,3,3,3]{4,3,2,1,0}, f32[32]{0}), window={size=3x3x3 pad=1_1x1_1x1_1}, dim_labels=bf012_oi012->bf012, custom_call_target=\"__cudnn$convBiasActivationForward\", backend_config={\"cudnn_conv_backend_config\":{\"activation_mode\":\"kNone\",\"conv_result_scale\":1,\"leakyrelu_alpha\":0,\"side_input_scale\":0},\"force_earliest_schedule\":false,\"operation_queue_id\":\"0\",\"wait_on_operation_queues\":[]} is taking a while...\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Epoch 2: val_loss did not improve from 8.38780\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2513s\u001b[0m 27s/step - coordinate_error: 0.5121 - detection_accuracy: 0.6644 - loss: 5.3475 - val_coordinate_error: 0.5256 - val_detection_accuracy: 0.5341 - val_loss: 8.8646 - learning_rate: 0.0010\n",
      "Epoch 3/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 20s/step - coordinate_error: 0.3988 - detection_accuracy: 0.6634 - loss: 2.4793 \n",
      "Epoch 3: val_loss improved from 8.38780 to 8.38159, saving model to /kaggle/working/best_motor_model.keras\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2354s\u001b[0m 25s/step - coordinate_error: 0.3986 - detection_accuracy: 0.6629 - loss: 2.4728 - val_coordinate_error: 0.4284 - val_detection_accuracy: 0.5341 - val_loss: 8.3816 - learning_rate: 0.0010\n",
      "Epoch 4/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 20s/step - coordinate_error: 0.3436 - detection_accuracy: 0.6588 - loss: 1.4052 \n",
      "Epoch 4: val_loss improved from 8.38159 to 8.04624, saving model to /kaggle/working/best_motor_model.keras\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2306s\u001b[0m 25s/step - coordinate_error: 0.3436 - detection_accuracy: 0.6589 - loss: 1.4056 - val_coordinate_error: 0.3502 - val_detection_accuracy: 0.5341 - val_loss: 8.0462 - learning_rate: 0.0010\n",
      "Epoch 5/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 19s/step - coordinate_error: 0.3268 - detection_accuracy: 0.6660 - loss: 1.3144 \n",
      "Epoch 5: val_loss improved from 8.04624 to 5.32722, saving model to /kaggle/working/best_motor_model.keras\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2269s\u001b[0m 24s/step - coordinate_error: 0.3269 - detection_accuracy: 0.6662 - loss: 1.3144 - val_coordinate_error: 0.3399 - val_detection_accuracy: 0.5341 - val_loss: 5.3272 - learning_rate: 0.0010\n",
      "Epoch 6/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 26s/step - coordinate_error: 0.3139 - detection_accuracy: 0.6482 - loss: 1.3540 \n",
      "Epoch 6: val_loss improved from 5.32722 to 1.42060, saving model to /kaggle/working/best_motor_model.keras\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2968s\u001b[0m 33s/step - coordinate_error: 0.3141 - detection_accuracy: 0.6484 - loss: 1.3537 - val_coordinate_error: 0.3325 - val_detection_accuracy: 0.5985 - val_loss: 1.4206 - learning_rate: 0.0010\n",
      "Epoch 7/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 20s/step - coordinate_error: 0.3422 - detection_accuracy: 0.6969 - loss: 1.3432 \n",
      "Epoch 7: val_loss improved from 1.42060 to 1.35438, saving model to /kaggle/working/best_motor_model.keras\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2326s\u001b[0m 25s/step - coordinate_error: 0.3422 - detection_accuracy: 0.6967 - loss: 1.3429 - val_coordinate_error: 0.3372 - val_detection_accuracy: 0.6742 - val_loss: 1.3544 - learning_rate: 0.0010\n",
      "Epoch 8/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 20s/step - coordinate_error: 0.3484 - detection_accuracy: 0.7197 - loss: 1.3183 \n",
      "Epoch 8: val_loss improved from 1.35438 to 1.18344, saving model to /kaggle/working/best_motor_model.keras\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2388s\u001b[0m 26s/step - coordinate_error: 0.3484 - detection_accuracy: 0.7198 - loss: 1.3188 - val_coordinate_error: 0.3074 - val_detection_accuracy: 0.7462 - val_loss: 1.1834 - learning_rate: 0.0010\n",
      "Epoch 9/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 20s/step - coordinate_error: 0.3165 - detection_accuracy: 0.7343 - loss: 1.1821 \n",
      "Epoch 9: val_loss did not improve from 1.18344\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2412s\u001b[0m 26s/step - coordinate_error: 0.3166 - detection_accuracy: 0.7342 - loss: 1.1831 - val_coordinate_error: 0.3070 - val_detection_accuracy: 0.7803 - val_loss: 1.1888 - learning_rate: 0.0010\n",
      "Epoch 10/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 21s/step - coordinate_error: 0.3319 - detection_accuracy: 0.7376 - loss: 1.1978 \n",
      "Epoch 10: val_loss did not improve from 1.18344\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2428s\u001b[0m 26s/step - coordinate_error: 0.3319 - detection_accuracy: 0.7373 - loss: 1.1983 - val_coordinate_error: 0.3381 - val_detection_accuracy: 0.5341 - val_loss: 8.0343 - learning_rate: 0.0010\n",
      "Epoch 11/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 19s/step - coordinate_error: 0.3313 - detection_accuracy: 0.6364 - loss: 1.3219 \n",
      "Epoch 11: val_loss did not improve from 1.18344\n",
      "\n",
      "Epoch 11: ReduceLROnPlateau reducing learning rate to 0.0005000000237487257.\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2290s\u001b[0m 25s/step - coordinate_error: 0.3315 - detection_accuracy: 0.6371 - loss: 1.3221 - val_coordinate_error: 0.3380 - val_detection_accuracy: 0.5720 - val_loss: 1.9309 - learning_rate: 0.0010\n",
      "Epoch 12/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 19s/step - coordinate_error: 0.3253 - detection_accuracy: 0.7324 - loss: 1.1861 \n",
      "Epoch 12: val_loss did not improve from 1.18344\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2266s\u001b[0m 24s/step - coordinate_error: 0.3253 - detection_accuracy: 0.7324 - loss: 1.1862 - val_coordinate_error: 0.3548 - val_detection_accuracy: 0.6136 - val_loss: 3.1966 - learning_rate: 5.0000e-04\n",
      "Epoch 13/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 19s/step - coordinate_error: 0.3357 - detection_accuracy: 0.7038 - loss: 1.3083 \n",
      "Epoch 13: val_loss improved from 1.18344 to 1.17208, saving model to /kaggle/working/best_motor_model.keras\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2266s\u001b[0m 24s/step - coordinate_error: 0.3357 - detection_accuracy: 0.7036 - loss: 1.3077 - val_coordinate_error: 0.3299 - val_detection_accuracy: 0.7841 - val_loss: 1.1721 - learning_rate: 5.0000e-04\n",
      "Epoch 14/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 19s/step - coordinate_error: 0.3327 - detection_accuracy: 0.6941 - loss: 1.2746 \n",
      "Epoch 14: val_loss improved from 1.17208 to 1.16098, saving model to /kaggle/working/best_motor_model.keras\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2260s\u001b[0m 24s/step - coordinate_error: 0.3326 - detection_accuracy: 0.6943 - loss: 1.2740 - val_coordinate_error: 0.3281 - val_detection_accuracy: 0.7614 - val_loss: 1.1610 - learning_rate: 5.0000e-04\n",
      "Epoch 15/15\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m0s\u001b[0m 20s/step - coordinate_error: 0.3254 - detection_accuracy: 0.7049 - loss: 1.2404 \n",
      "Epoch 15: val_loss did not improve from 1.16098\n",
      "\u001b[1m87/87\u001b[0m \u001b[32m\u001b[0m\u001b[37m\u001b[0m \u001b[1m2321s\u001b[0m 25s/step - coordinate_error: 0.3254 - detection_accuracy: 0.7047 - loss: 1.2409 - val_coordinate_error: 0.3129 - val_detection_accuracy: 0.7765 - val_loss: 1.2071 - learning_rate: 5.0000e-04\n",
      "Restoring model weights from the end of the best epoch: 14.\n",
      "[TIMER] Model training: 36230.755s\n"
     ]
    },
    {
     "data": {
      "image/png": "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0iX+/PNP/ve///Hss89y/vx5li9fzjfffIOnpydApscRd+7coUWLFsTHxzNq1CjKlCnDokWLePrpp1m1ahXPPPOM0fqffvopVlZWjBs3jqioKD7//HNefPFF9u3bl6Of39KlS3n22Wexs7Ojf//+zJkzhwMHDhiduh0bG0vr1q05c+YMgwcPpmHDhty9e5e1a9dy/fp1PD090Wq1dO/enS1bttCvXz/efPNNYmJi2LRpEydPniQwMDDnv9Q0qampBAcH06pVK7788ktDxVlOj62y+920a9cOPz8/li5dmu7nunTpUgIDA+V0dSGEsAB//vknlStXzvT93uOGDh3KokWL6N27N2PHjmXfvn188sknnDlzxujD08mTJzNlyhQ6duzIa6+9xrlz5wyvg7t37zbKJ2SUz8jve3PI2XvPAwcOsGfPHvr164evry9Xrlxhzpw5tGvXjtOnT+Pk5GSy45qsxMTEGH2ArlemTBmjDwm2bt3Kr7/+ysiRI/H09CQgIMAw2+z111/Hy8uLiRMnEhcXZ5LfgxCFRhGiAIwYMUJ5/M+rbdu2CqDMnTs33frx8fHplr3yyiuKk5OTkpiYaFg2cOBAxd/f3/B9aGioAihlypRR7t+/b1j+xx9/KIDy559/GpZNmjQpXUyAYmdnp1y8eNGw7NixYwqgzJw507CsR48eipOTk3Ljxg3DsgsXLig2NjbptpmRjB7fJ598omg0GuXq1atGjw9Qpk6darRugwYNlEaNGhm+X7NmjQIon3/+uWFZamqq0rp1awVQFixYkG1MTZo0UXx9fRWtVmtYtn79egVQvv/+e8M2k5KSjO734MEDpWzZssrgwYONlgPKpEmTDN8vWLBAAZTQ0FBFURQlPDxcsbOzU7p166bodDrDeu+9954CKAMHDjQsS0xMNIpLUdTftb29vdHP5sCBA5k+3sf/VvQ/s48++shovd69eysajcbobyCnfxcZ0f9NfvHFF5muM336dAVQlixZYliWnJysNG/eXHFxcVGio6MVRVGUN998U3Fzc1NSU1Mz3Va9evWUbt26ZRmTEEIUdfrXlAMHDmS6jru7u9KgQQPD9x06dFCCgoKMjiN0Op3SokULpWrVqoZlK1euVABl27ZtRtuLiYlRPDw8lGHDhhktv337tuLu7m60vE2bNoqrq6vRa7p+f3pffPGF0evio/z9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nV3neHZ2NklJSfU+z+l00rlzZ/r27cu9997LVVddxfTp0wFqn3eqr/nggw+Sn59fu+3atet0hyUiItLsWFpIHzFiBIZhHLO9/vrrVoYlIiIiIiIiEhBCQkLo378/GRkZtcd8Ph8ZGRkMGTLkpF/H5/PVtmXp0KEDSUlJdV6zoKCAJUuWNPiaWtdMRETsTD3SRURERERERALY1KlTGT9+PAMGDGDQoEE899xzFBcXM2HCBABuvvlm2rRpUzvjfPr06QwYMIBOnTpRXl7OZ599xhtvvMHMmTMBcDgc3HPPPfz+978nPT2dDh06MG3aNFJSUhg3bpxVwxQREbGUCukiIiIiIiIiAezaa69l//79PPzww2RlZdG3b19mz55du1hoZmYmTufhC9KLi4v55S9/ye7duwkLC6Nbt278+9//5tprr60959e//jXFxcXccccd5OXlMXz4cGbPnk1oaGiTj09ERKQ5cBiGYVgdxOkqKCjA4/GQn5+vS8ZERKRZUq46efpaiYhIIFC+Onn6WomISHN3KrkqoGek13wGUFBQYHEkIiIix1eTowL4c+smo7wuIiKBQLn95Cm3i4hIc3cqeT2gC+mFhYUApKamWhyJiIhIwwoLC/F4PFaH0awpr4uISCBRbj8x5XYREQkUJ5PXA7q1i8/nY+/evURFReFwOM749QoKCkhNTWXXrl22u+zMzmMDe4/PzmMDe4/PzmMDe4/Pn2MzDIPCwkJSUlLq9CaVYymvnzw7jw3sPT47jw3sPT47jw3sPT5/j025/eT5M7fb+WcU7D0+O48N7D0+O48N7D0+O48NrPubPaBnpDudTtq2bev3142OjrblDxnYe2xg7/HZeWxg7/HZeWxg7/H5a2yarXZylNdPnZ3HBvYen53HBvYen53HBvYenz/Hptx+chojt9v5ZxTsPT47jw3sPT47jw3sPT47jw2a/m92fXwuIiIiIiIiIiIiItIAFdJFRERERERERERERBqgQvoR3G43jzzyCG632+pQ/M7OYwN7j8/OYwN7j8/OYwN7j8/OY2tJ7Px9tPPYwN7js/PYwN7js/PYwN7js/PYWhK7fx/tPD47jw3sPT47jw3sPT47jw2sG19ALzYqIiIiIiIiIiIiItLYNCNdRERERERERERERKQBKqSLiIiIiIiIiIiIiDRAhXQRERERERERERERkQaokF5txowZpKWlERoayuDBg1m6dKnVIfnF9OnTGThwIFFRUSQmJjJu3Dg2btxodViN4o9//CMOh4N77rnH6lD8Zs+ePdx4443Ex8cTFhZGr169+P77760O64x5vV6mTZtGhw4dCAsLo1OnTjzxxBME6pIN33zzDZdddhkpKSk4HA4++OCDOo8bhsHDDz9McnIyYWFhjBw5ks2bN1sT7ClqaGyVlZU88MAD9OrVi4iICFJSUrj55pvZu3evdQGfohN9745055134nA4eO6555osPjl9yuuBT3k9cCivB05eB3vnduV1e7NjbldeD2x2zetgr9yuvK687k8qpAPvvvsuU6dO5ZFHHmHFihX06dOH0aNHk5OTY3VoZ+zrr79m4sSJLF68mLlz51JZWcnFF19McXGx1aH51bJly3jppZfo3bu31aH4zaFDhxg2bBjBwcF8/vnn/Pjjj/z5z38mNjbW6tDO2FNPPcXMmTN54YUXWL9+PU899RRPP/00f/3rX60O7bQUFxfTp08fZsyYcdzHn376aZ5//nlefPFFlixZQkREBKNHj6asrKyJIz11DY2tpKSEFStWMG3aNFasWMH777/Pxo0bufzyyy2I9PSc6HtXY9asWSxevJiUlJQmikzOhPJ64FNeDyzK64GT18HeuV153b7smtuV1wOXnfM62Cu3K68rr/uVIcagQYOMiRMn1t73er1GSkqKMX36dAujahw5OTkGYHz99ddWh+I3hYWFRnp6ujF37lzj/PPPN6ZMmWJ1SH7xwAMPGMOHD7c6jEZx6aWXGrfeemudY1deeaVxww03WBSR/wDGrFmzau/7fD4jKSnJ+NOf/lR7LC8vz3C73cbbb79tQYSn7+ixHc/SpUsNwNi5c2fTBOVH9Y1v9+7dRps2bYx169YZ7du3N5599tkmj01OjfJ6YFNeDzzK64GZ1w3D3rlded1eWkpuV14PHHbO64Zh39yuvK68fqZa/Iz0iooKli9fzsiRI2uPOZ1ORo4cyaJFiyyMrHHk5+cDEBcXZ3Ek/jNx4kQuvfTSOt9DO/joo48YMGAAV199NYmJifTr14+///3vVoflF0OHDiUjI4NNmzYBsHr1ar777jvGjh1rcWT+t337drKysur8fHo8HgYPHmzb3zEOh4OYmBirQ/ELn8/HTTfdxP3330/Pnj2tDkdOgvJ64FNeDzzK6/bN62Cv3K68HphaUm5XXg8cds7r0HJyu/J6YLMirwc1yb/SjOXm5uL1emndunWd461bt2bDhg0WRdU4fD4f99xzD8OGDeOss86yOhy/eOedd1ixYgXLli2zOhS/27ZtGzNnzmTq1Kn89re/ZdmyZdx9992EhIQwfvx4q8M7I7/5zW8oKCigW7duuFwuvF4vTz75JDfccIPVofldVlYWwHF/x9Q8ZhdlZWU88MADXH/99URHR1sdjl889dRTBAUFcffdd1sdipwk5fXAprwemJTX7ZnXwX65XXk9MLWU3K68HljsnNeh5eR25fXAZkVeb/GF9JZk4sSJrFu3ju+++87qUPxi165dTJkyhblz5xIaGmp1OH7n8/kYMGAAf/jDHwDo168f69at48UXXwz4xPyf//yHN998k7feeouePXuyatUq7rnnHlJSUgJ+bC1VZWUl11xzDYZhMHPmTKvD8Yvly5fzl7/8hRUrVuBwOKwOR+QYyuuBRXldAo3dcrvyujR3yuuBxc55HZTb7Uh53T9afGuXhIQEXC4X2dnZdY5nZ2eTlJRkUVT+N2nSJD755BPmzZtH27ZtrQ7HL5YvX05OTg5nn302QUFBBAUF8fXXX/P8888TFBSE1+u1OsQzkpycTI8ePeoc6969O5mZmRZF5D/3338/v/nNb7juuuvo1asXN910E7/61a+YPn261aH5Xc3vETv/jqlJyDt37mTu3Lm2+GQb4NtvvyUnJ4d27drV/o7ZuXMn9957L2lpaVaHJ/VQXg9cyuuBS3ndfr9j7JjbldcDV0vI7crrgcfOeR1aTm5XXg9cVuX1Fl9IDwkJoX///mRkZNQe8/l8ZGRkMGTIEAsj8w/DMJg0aRKzZs3iq6++okOHDlaH5DcXXXQRa9euZdWqVbXbgAEDuOGGG1i1ahUul8vqEM/IsGHD2LhxY51jmzZton379hZF5D8lJSU4nXV//bhcLnw+n0URNZ4OHTqQlJRU53dMQUEBS5YsscXvmJqEvHnzZr788kvi4+OtDslvbrrpJtasWVPnd0xKSgr3338/c+bMsTo8qYfyeuBSXg9cyuv2yetg39yuvB647JzbldcDl53zOrSc3K68Hrisyutq7QJMnTqV8ePHM2DAAAYNGsRzzz1HcXExEyZMsDq0MzZx4kTeeustPvzwQ6Kiomp7PHk8HsLCwiyO7sxERUUd0zsuIiKC+Ph4W/SU+9WvfsXQoUP5wx/+wDXXXMPSpUt5+eWXefnll60O7YxddtllPPnkk7Rr146ePXuycuVKnnnmGW699VarQzstRUVFbNmypfb+9u3bWbVqFXFxcbRr14577rmH3//+96Snp9OhQwemTZtGSkoK48aNsy7ok9TQ2JKTk7nqqqtYsWIFn3zyCV6vt/Z3TFxcHCEhIVaFfdJO9L07+k1GcHAwSUlJdO3atalDlVOgvB6YlNcDl/J64OR1sHduV163L7vmduX1wGXnvA72yu3K68rrfmWIYRiG8de//tVo166dERISYgwaNMhYvHix1SH5BXDc7bXXXrM6tEZx/vnnG1OmTLE6DL/5+OOPjbPOOstwu91Gt27djJdfftnqkPyioKDAmDJlitGuXTsjNDTU6Nixo/HQQw8Z5eXlVod2WubNm3fc/2fjx483DMMwfD6fMW3aNKN169aG2+02LrroImPjxo3WBn2SGhrb9u3b6/0dM2/ePKtDPykn+t4drX379sazzz7bpDHK6VFetwfl9cCgvB44ed0w7J3bldftzY65XXk9sNk1rxuGvXK78rryuj85DMMwTrn6LiIiIiIiIiIiIiLSQrT4HukiIiIiIiIiIiIiIg1RIV1EREREREREREREpAEqpIuIiIiIiIiIiIiINECFdBERERERERERERGRBqiQLiIiIiIiIiIiIiLSABXSRUREREREREREREQaoEK6iIiIiIiIiIiIiEgDVEgXEREREREREREREWmACuki4hcOh4MPPvjA6jBERETED5TXRURE7EN5XcQ/VEgXsYFbbrkFh8NxzDZmzBirQxMREZFTpLwuIiJiH8rrIvYRZHUAIuIfY8aM4bXXXqtzzO12WxSNiIiInAnldREREftQXhexB81IF7EJt9tNUlJSnS02NhYwL+OaOXMmY8eOJSwsjI4dO/K///2vzvPXrl3LhRdeSFhYGPHx8dxxxx0UFRXVOefVV1+lZ8+euN1ukpOTmTRpUp3Hc3Nz+clPfkJ4eDjp6el89NFHjTtoERERm1JeFxERsQ/ldRF7UCFdpIWYNm0aP/3pT1m9ejU33HAD1113HevXrweguLiY0aNHExsby7Jly/jvf//Ll19+WSfxzpw5k4kTJ3LHHXewdu1aPvroIzp37lzn33jssce45pprWLNmDZdccgk33HADBw8ebNJxioiItATK6yIiIvahvC4SIAwRCXjjx483XC6XERERUWd78sknDcMwDMC488476zxn8ODBxl133WUYhmG8/PLLRmxsrFFUVFT7+Keffmo4nU4jKyvLMAzDSElJMR566KF6YwCM3/3ud7X3i4qKDMD4/PPP/TZOERGRlkB5XURExD6U10XsQz3SRWziggsuYObMmXWOxcXF1e4PGTKkzmNDhgxh1apVAKxfv54+ffoQERFR+/iwYcPw+Xxs3LgRh8PB3r17ueiiixqMoXfv3rX7ERERREdHk5OTc7pDEhERabGU10VEROxDeV3EHlRIF7GJiIiIYy7d8pewsLCTOi84OLjOfYfDgc/na4yQREREbE15XURExD6U10XsQT3SRVqIxYsXH3O/e/fuAHTv3p3Vq1dTXFxc+/iCBQtwOp107dqVqKgo0tLSyMjIaNKYRURE5PiU10VEROxDeV0kMGhGuohNlJeXk5WVVedYUFAQCQkJAPz3v/9lwIABDB8+nDfffJOlS5fyyiuvAHDDDTfwyCOPMH78eB599FH279/P5MmTuemmm2jdujUAjz76KHfeeSeJiYmMHTuWwsJCFixYwOTJk5t2oCIiIi2A8rqIiIh9KK+L2IMK6SI2MXv2bJKTk+sc69q1Kxs2bADMFbrfeecdfvnLX5KcnMzbb79Njx49AAgPD2fOnDlMmTKFgQMHEh4ezk9/+lOeeeaZ2tcaP348ZWVlPPvss9x3330kJCRw1VVXNd0ARUREWhDldREREftQXhexB4dhGIbVQYhI43I4HMyaNYtx48ZZHYqIiIicIeV1ERER+1BeFwkc6pEuIiIiIiIiIiIiItIAFdJFRERERERERERERBqg1i4iIiIiIiIiIiIiIg3QjHQRERERERERERERkQaokC4iIiIiIiIiIiIi0gAV0kVEREREREREREREGqBCuoiIiIiIiIiIiIhIA1RIFxERERERERERERFpgArpIiIiIiIiIiIiIiINUCFdRERERERERERERKQBKqSLiIiIiIiIiIiIiDRAhXQRERERERERERERkQb8f/C+gqqRLNsfAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 1500x500 with 3 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Generating submission\n",
      "Found 3 tomograms in test directory\n",
      "Loading model from /kaggle/working/best_motor_model.keras\n",
      "\n",
      "Processing tomogram 1/3: tomo_003acc\n",
      "Processing tomogram tomo_003acc with progressive sampling\n",
      "Found 500 total slices for tomogram tomo_003acc\n",
      "STAGE 1: Performing coarse sampling with 100 slices (20.0%)\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "E0000 00:00:1745837747.901755      67 gpu_timer.cc:82] Delay kernel timed out: measured time has sub-optimal accuracy. There may be a missing warmup execution, please investigate in Nsight Systems.\n",
      "E0000 00:00:1745837748.091319      67 gpu_timer.cc:82] Delay kernel timed out: measured time has sub-optimal accuracy. There may be a missing warmup execution, please investigate in Nsight Systems.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[TIMER] Coarse inference: 11.458s\n",
      "STAGE 2: Found 1 potential detections in coarse scan\n",
      "Sampling 80 additional slices in region of interest\n",
      "Total detections before NMS: 81\n",
      "Detections after NMS: 73\n",
      "Motor found in tomo_003acc at position: z=217.0, y=1195.8, x=1070.8 with confidence 1.119\n",
      "Motor found in tomo_003acc at position: z=217, y=1196, x=1071\n",
      "Current detection rate: 1/1 (100.0%)\n",
      "\n",
      "Processing tomogram 2/3: tomo_00e047\n",
      "Processing tomogram tomo_00e047 with progressive sampling\n",
      "Found 300 total slices for tomogram tomo_00e047\n",
      "STAGE 1: Performing coarse sampling with 60 slices (20.0%)\n",
      "[TIMER] Coarse inference: 5.075s\n",
      "STAGE 2: Found 1 potential detections in coarse scan\n",
      "Sampling 49 additional slices in region of interest\n",
      "Total detections before NMS: 50\n",
      "Detections after NMS: 11\n",
      "Motor found in tomo_00e047 at position: z=166.0, y=503.5, x=517.9 with confidence 0.758\n",
      "Motor found in tomo_00e047 at position: z=166, y=504, x=518\n",
      "Current detection rate: 2/2 (100.0%)\n",
      "\n",
      "Processing tomogram 3/3: tomo_01a877\n",
      "Processing tomogram tomo_01a877 with progressive sampling\n",
      "Found 300 total slices for tomogram tomo_01a877\n",
      "STAGE 1: Performing coarse sampling with 60 slices (20.0%)\n",
      "[TIMER] Coarse inference: 4.325s\n",
      "STAGE 2: Found 1 potential detections in coarse scan\n",
      "Sampling 48 additional slices in region of interest\n",
      "Total detections before NMS: 49\n",
      "Detections after NMS: 15\n",
      "Motor found in tomo_01a877 at position: z=154.0, y=504.8, x=510.1 with confidence 0.709\n",
      "Motor found in tomo_01a877 at position: z=154, y=505, x=510\n",
      "Current detection rate: 3/3 (100.0%)\n",
      "\n",
      "Submission complete!\n",
      "Motors detected: 3/3 (100.0%)\n",
      "Submission saved to: /kaggle/working/submission.csv\n",
      "\n",
      "Submission preview:\n",
      "       tomo_id  Motor axis 0  Motor axis 1  Motor axis 2\n",
      "0  tomo_003acc           217          1196          1071\n",
      "1  tomo_00e047           166           504           518\n",
      "2  tomo_01a877           154           505           510\n",
      "\n",
      "Total execution time: 36315.32 seconds (605.26 minutes)\n",
      "\n",
      "Total execution time: 36315.32 seconds (605.26 minutes)\n"
     ]
    }
   ],
   "source": [
    "# Run the full pipeline\n",
    "if __name__ == \"__main__\":\n",
    "    # Time entire process\n",
    "    start_time = time.time()\n",
    "    \n",
    "    # Run pipeline\n",
    "    submission = run_pipeline()\n",
    "    \n",
    "    # Print total execution time\n",
    "    elapsed = time.time() - start_time\n",
    "    print(f\"\\nTotal execution time: {elapsed:.2f} seconds ({elapsed/60:.2f} minutes)\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "9fa8f7ef",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2025-04-28T10:56:33.742687Z",
     "iopub.status.busy": "2025-04-28T10:56:33.742444Z",
     "iopub.status.idle": "2025-04-28T10:56:33.746373Z",
     "shell.execute_reply": "2025-04-28T10:56:33.745772Z"
    },
    "papermill": {
     "duration": 0.06909,
     "end_time": "2025-04-28T10:56:33.747477",
     "exception": false,
     "start_time": "2025-04-28T10:56:33.678387",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "FINISHED\n"
     ]
    }
   ],
   "source": [
    "print('FINISHED')"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "nvidiaTeslaT4",
   "dataSources": [
    {
     "databundleVersionId": 11294684,
     "sourceId": 91249,
     "sourceType": "competition"
    }
   ],
   "dockerImageVersionId": 31012,
   "isGpuEnabled": true,
   "isInternetEnabled": false,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.11"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 36338.044637,
   "end_time": "2025-04-28T10:56:36.979051",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-04-28T00:50:58.934414",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
